#!/bin/bash

# Read the string from the user
echo "Enter a string:"
read input

# Reverse the string
reverse=$(echo "$input" | rev)

# Check if the string is equal to its reverse
if [ "$input" = "$reverse" ]; then
    echo "The string '$input' is a palindrome."
else
    echo "The string '$input' is not a palindrome."
fi
#!/bin/bash

# Read the number of elements
echo "Enter the number of elements:"
read n

# Read the elements into an array
echo "Enter the elements (space-separated):"
read -a arr

# Bubble Sort Algorithm
for ((i = 0; i < n-1; i++)); do
    for ((j = 0; j < n-i-1; j++)); do
        if ((arr[j] > arr[j+1])); then
            # Swap elements
            temp=${arr[j]}
            arr[j]=${arr[j+1]}
            arr[j+1]=$temp
        fi
    done
done

# Print the sorted array
echo "Sorted array:"
echo "${arr[@]}"
#!/bin/bash

# Read the string from the user
echo "Enter a string:"
read input

# Reverse the string using 'rev' command
reversed=$(echo "$input" | rev)

# Display the reversed string
echo "Reversed string: $reversed"
#!/bin/bash
echo "Enter the string to search in:"
read original_string
echo "Enter the string to search for:"
read search_string

# Use AWK to check if the search_string is a part of original_string
echo "$original_string" | awk -v search="$search_string" '
{
    if (index($0, search) > 0) {
        print "String found!"
    } else {
        print "String not found!"
    }
}'
#!/bin/bash

# Function to perform Insertion Sort
insertion_sort() {
    arr=("$@")  # Accepts an array of numbers
    n=${#arr[@]}  # Get the length of the array

    for ((i = 1; i < n; i++)); do
        key=${arr[$i]}  # The element to be inserted
        j=$((i - 1))  # Start from the element before the current key

        # Move elements of arr[0..i-1], that are greater than key,
        # to one position ahead of their current position
        while ((j >= 0 && arr[j] > key)); do
            arr[$((j + 1))]=${arr[$j]}
            j=$((j - 1))
        done

        # Insert the key at the correct position
        arr[$((j + 1))]=$key
    done

    # Print sorted array
    echo "Sorted array: ${arr[@]}"
}

# Example usage
echo "Enter numbers to be sorted (separated by space):"
read -a arr  # Read an array from user input

insertion_sort "${arr[@]}"  # Call the sorting function




Print all data:

bash
Copy code
awk '{print}' emp.txt
This command prints all lines in emp.txt.

Print lines containing "manager":

bash
Copy code
awk '/manager/ {print}' emp.txt
This command prints only the lines where "manager" is in the position field.

Print only the employee IDs:

bash
Copy code
awk '{print $1}' emp.txt
This prints the first field (employee IDs) from each line.

Print position and salary:

bash
Copy code
awk '{print $2, $4}' emp.txt
This prints the second field (position) and the fourth field (salary) from each line.

Print all lines with line numbers:

bash
Copy code
awk '{print NR, $0}' emp.txt
This prints each line with a line number.

Print employee ID and salary only:

bash
Copy code
awk '{print $1, $NF}' emp.txt
$NF represents the last field (salary) in each line. This command prints the employee ID and salary.

Print lines from line 3 to 6:

bash
Copy code
awk 'NR ==3, NR==6 {print NR, $0}' emp.txt
This command prints lines from line number 3 to line number 6.

Print employee ID with salary:

bash
Copy code
awk '{print $1 "= " $NF}' emp.txt
This prints the employee ID followed by an equals sign (=) and their salary.

Sum of all salaries:

bash
Copy code
awk '{sum += $4} END {print sum}' emp.txt
This command adds up all salaries and prints the total after processing all lines.

Find maximum salary:

bash
Copy code
awk '{if($4 > max) max = $4} END {print max}' emp.txt
This command finds the maximum salary by comparing each salary and storing the highest in max, then printing it at the end.

Filter employees with a salary below 30000:

bash
Copy code
awk '{if ($4 < 30000) print NR, $0}' emp.txt
This command prints the lines where the salary is less than 30000, with line numbers.

Filter specific employee ID (e.g., "e"):

bash
Copy code
awk '{if ($1 == "e") print $0}' emp.txt
This command finds and prints only the line with employee ID "e."

Print squares of numbers from 1 to 5 using a loop:

bash
Copy code
awk 'BEGIN {for(i=1; i<=5; i++) print "square of", i, "=", i*i;}'



#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>
#include <unistd.h>

#define MAX_READERS 10
#define MAX_WRITERS 10

void *read_function(void *arg);
void *write_function(void *arg);

int readcount = 0;
pthread_mutex_t r_mutex, w_mutex;

int main() {
    int n1, n2;
    pthread_t readers[MAX_READERS], writers[MAX_WRITERS];

    pthread_mutex_init(&r_mutex, NULL);
    pthread_mutex_init(&w_mutex, NULL);

    printf("Enter the number of readers you want to create (max %d):\n", MAX_READERS);
    scanf("%d", &n1);
    printf("Enter the number of writers you want to create (max %d):\n", MAX_WRITERS);
    scanf("%d", &n2);

    if (n1 > MAX_READERS || n2 > MAX_WRITERS) {
        printf("Number of readers or writers exceeds the limit.\n");
        return 1;
    }

    for (int i = 0; i < n1; i++) {
        pthread_create(&readers[i], NULL, read_function, NULL);
    }
    for (int i = 0; i < n2; i++) {
        pthread_create(&writers[i], NULL, write_function, NULL);
    }

    for (int i = 0; i < n1; i++) {
        pthread_join(readers[i], NULL);
    }
    for (int i = 0; i < n2; i++) {
        pthread_join(writers[i], NULL);
    }

    pthread_mutex_destroy(&r_mutex);
    pthread_mutex_destroy(&w_mutex);

    return 0;
}

void *read_function(void *arg) {
    pthread_mutex_lock(&r_mutex);
    readcount++;
    if (readcount == 1) {
        pthread_mutex_lock(&w_mutex);
    }
    pthread_mutex_unlock(&r_mutex);

    printf("Reader %ld is inside\n", pthread_self());
    sleep(3); // Simulate reading

    pthread_mutex_lock(&r_mutex);
    readcount--;
    if (readcount == 0) {
        pthread_mutex_unlock(&w_mutex);
    }
    pthread_mutex_unlock(&r_mutex);

    printf("Reader %ld is leaving\n", pthread_self());
    return NULL;
}

void *write_function(void *arg) {
    printf("Writer %ld is trying to enter\n", pthread_self());
    pthread_mutex_lock(&w_mutex);
    printf("Writer %ld entered the class\n", pthread_self());
    sleep(2); // Simulate writing
    pthread_mutex_unlock(&w_mutex);
    printf("Writer %ld left the class\n", pthread_self());
    return NULL;
}





#include <semaphore.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <pthread.h>

sem_t x, y;
pthread_t tid;
pthread_t writerthreads[100], readerthreads[100];
int readercount = 0;

void *reader(void *param)
{
    sem_wait(&x);
    readercount++;
    if (readercount == 1)
        sem_wait(&y);
    sem_post(&x);
    printf("%d reader is inside\n", readercount);
    usleep(3);
    sem_wait(&x);
    readercount--;
    if (readercount == 0)
    {
        sem_post(&y);
    }
    sem_post(&x);
    printf("%d Reader is leaving\n", readercount + 1);
    return NULL;
}

void *writer(void *param)
{
    printf("Writer is trying to enter\n");
    sem_wait(&y);
    printf("Writer has entered\n");
    sem_post(&y);
    printf("Writer is leaving\n");
    return NULL;
}

int main()
{
    int n2, i;
    printf("Enter the number of readers:");
    scanf("%d", &n2);
    printf("\n");
    int n1[n2];
    sem_init(&x, 0, 1);
    sem_init(&y, 0, 1);
    for (i = 0; i < n2; i++)
    {
        pthread_create(&writerthreads[i], NULL, reader, NULL);
        pthread_create(&readerthreads[i], NULL, writer, NULL);
    }
    for (i = 0; i < n2; i++)
    {
        pthread_join(writerthreads[i], NULL);
        pthread_join(readerthreads[i], NULL);
    }
}





#include <stdio.h>
#include <pthread.h>
#include <stdlib.h>
#include <time.h>
#include <unistd.h> // For sleep function

#define MAX_ITEMS 5
#define BUFFER_SIZE 5

pthread_mutex_t mutex;
pthread_cond_t not_empty;
pthread_cond_t not_full;
int buffer[BUFFER_SIZE];
int in = 0;
int out = 0;
int count = 0; // Number of items currently in the buffer

void *producer(void *pno)
{
    int item;
    for (int i = 0; i < MAX_ITEMS; i++)
    {
        item = rand() % 100; // Produce a random item

        pthread_mutex_lock(&mutex);

        while (count == BUFFER_SIZE)
        {
            // Buffer is full, wait for a slot to be free
            pthread_cond_wait(&not_full, &mutex);
        }

        buffer[in] = item;
        printf("Producer %d: Insert Item %d at %d\n", *((int *)pno), buffer[in], in);
        in = (in + 1) % BUFFER_SIZE;
        count++;

        pthread_cond_signal(&not_empty); // Signal that there is an item available
        pthread_mutex_unlock(&mutex);

        sleep(rand() % 2); // Simulate variable production time
    }
    return NULL;
}

void *consumer(void *cno)
{
    int item;
    for (int i = 0; i < MAX_ITEMS; i++)
    {
        pthread_mutex_lock(&mutex);

        while (count == 0)
        {
            // Buffer is empty, wait for an item to be available
            printf("Consumer %d: Buffer is empty, waiting for items...\n", *((int *)cno));
            pthread_cond_wait(&not_empty, &mutex);
        }

        item = buffer[out];
        printf("Consumer %d: Remove Item %d from %d\n", *((int *)cno), item, out);
        out = (out + 1) % BUFFER_SIZE;
        count--;

        pthread_cond_signal(&not_full); // Signal that there is a slot available
        pthread_mutex_unlock(&mutex);

        sleep(rand() % 2); // Simulate variable consumption time
    }
    return NULL;
}

int main()
{
    pthread_t producers[5], consumers[5];
    int ids[5];

    pthread_mutex_init(&mutex, NULL);
    pthread_cond_init(&not_empty, NULL);
    pthread_cond_init(&not_full, NULL);

    srand(time(NULL)); // Seed the random number generator

    for (int i = 0; i < 5; i++)
    {
        ids[i] = i + 1; // Producer/Consumer IDs
        pthread_create(&producers[i], NULL, producer, (void *)&ids[i]);
        pthread_create(&consumers[i], NULL, consumer, (void *)&ids[i]);
    }

    for (int i = 0; i < 5; i++)
    {
        pthread_join(producers[i], NULL);
        pthread_join(consumers[i], NULL);
    }

    pthread_mutex_destroy(&mutex);
    pthread_cond_destroy(&not_empty);
    pthread_cond_destroy(&not_full);

    return 0;
}






#include <stdio.h>
#include <pthread.h>
#include <stdlib.h>
#include <semaphore.h>
#include <time.h>
#include <unistd.h> // Include this for the sleep function

#define MAX_ITEMS 5
#define BUFFER_SIZE 5

sem_t empty;
sem_t full;
int buffer[BUFFER_SIZE];
int in = 0;
int out = 0;

void *producer(void *pno) {
    int item;
    for (int i = 0; i < MAX_ITEMS; i++) {
        item = rand() % 100; // Produce a random item
        
        sem_wait(&empty);    // Wait for an empty slot
        buffer[in] = item;
        printf("Producer %d: Insert Item %d at %d\n", *((int *)pno), buffer[in], in);
        in = (in + 1) % BUFFER_SIZE;
        sem_post(&full);     // Signal that an item has been added
        
        sleep(rand() % 2);  // Simulate variable production time
    }
    return NULL;
}

void *consumer(void *cno) {
    int item;
    for (int i = 0; i < MAX_ITEMS; i++) {
        sem_wait(&full);     // Wait for an item to be available
        
        // Print a message if the buffer is empty
        if ((in - out + BUFFER_SIZE) % BUFFER_SIZE == 0) {
            printf("Consumer %d: Buffer is empty, waiting for items...\n", *((int *)cno));
        }

        item = buffer[out];
        printf("Consumer %d: Remove Item %d from %d\n", *((int *)cno), item, out);
        out = (out + 1) % BUFFER_SIZE;
        sem_post(&empty);    // Signal that a slot has been freed
        
        sleep(rand() % 2);  // Simulate variable consumption time
    }
    return NULL;
}

int main() {
    pthread_t producers[5], consumers[5];
    int ids[5];
    
    sem_init(&empty, 0, BUFFER_SIZE); // Initialize semaphore for empty slots
    sem_init(&full, 0, 0);            // Initialize semaphore for full slots
    
    srand(time(NULL)); // Seed the random number generator

    for (int i = 0; i < 5; i++) {
        ids[i] = i + 1; // Producer/Consumer IDs
        pthread_create(&producers[i], NULL, producer, (void *)&ids[i]);
        pthread_create(&consumers[i], NULL, consumer, (void *)&ids[i]);
    }

    for (int i = 0; i < 5; i++) {
        pthread_join(producers[i], NULL);
        pthread_join(consumers[i], NULL);
    }

    sem_destroy(&empty);
    sem_destroy(&full);
    
    return 0;
}


firstcomefitstserve

#include <stdio.h>

void print_gantt_chart(int p[], int bt[], int ct[], int n) {
    int i, j;

    // Print top bar
    printf(" ");
    for (i = 0; i < n; i++) {
        for (j = 0; j < bt[i]; j++) printf("--");
        printf(" ");
    }
    printf("\n|");

    // Print process IDs in the middle
    for (i = 0; i < n; i++) {
        for (j = 0; j < bt[i] - 1; j++) printf(" ");
        printf("P%d", p[i]);
        for (j = 0; j < bt[i] - 1; j++) printf(" ");
        printf("|");
    }
    printf("\n ");

    // Print bottom bar
    for (i = 0; i < n; i++) {
        for (j = 0; j < bt[i]; j++) printf("--");
        printf(" ");
    }
    printf("\n");

    // Print the timeline
    printf("0");
    for (i = 0; i < n; i++) {
        for (j = 0; j < bt[i]; j++) printf("  ");
        if (ct[i] > 9) printf("\b"); // Adjust for numbers > 9
        printf("%d", ct[i]);
    }
    printf("\n");
}

int main() { 
    int p[10], bt[10], wt[10], tat[10], ct[10], at[10];  
    int i, j, temp, n;
    float awt = 0, atat = 0;

    // Input number of processes
    printf("Enter number of processes: ");
    scanf("%d", &n);

    // Input process IDs
    printf("Enter %d process IDs: ", n);
    for (i = 0; i < n; i++) {
        scanf("%d", &p[i]);
    }

    // Input arrival times
    printf("Enter %d arrival times: ", n);
    for (i = 0; i < n; i++) {
        scanf("%d", &at[i]);
    }

    // Input burst times
    printf("Enter %d burst times: ", n);
    for (i = 0; i < n; i++) {
        scanf("%d", &bt[i]);
    }

    // Sort processes based on Arrival Time (AT)
    for (i = 0; i < n - 1; i++) {
        for (j = 0; j < n - i - 1; j++) {
            if (at[j] > at[j + 1]) {
                // Swap Arrival Time
                temp = at[j];
                at[j] = at[j + 1];
                at[j + 1] = temp;
                
                // Swap Burst Time
                temp = bt[j];
                bt[j] = bt[j + 1];
                bt[j + 1] = temp;
                
                // Swap Process ID
                temp = p[j];
                p[j] = p[j + 1];
                p[j + 1] = temp;
            }
        }
    }

    // Calculate Completion Times
    ct[0] = at[0] + bt[0];
    for (i = 1; i < n; i++) {
        int wait_time = (ct[i - 1] > at[i]) ? ct[i - 1] : at[i];
        ct[i] = wait_time + bt[i];
    }

    // Print the process table
    printf("\nPID\tA.T\tB.T\tC.T\tTAT\tWT");
    for (i = 0; i < n; i++) {
        tat[i] = ct[i] - at[i];
        wt[i] = tat[i] - bt[i];
        atat += tat[i];
        awt += wt[i];
        printf("\n%d\t%d\t%d\t%d\t%d\t%d", p[i], at[i], bt[i], ct[i], tat[i], wt[i]);
    }
    atat = atat / n;
    awt = awt / n;

    printf("\nAverage Turnaround Time: %.2f", atat);
    printf("\nAverage Waiting Time: %.2f\n", awt);

    // Print the Gantt chart
    print_gantt_chart(p, bt, ct, n);

    return 0;
}


sjpnp 

#include <stdio.h>
#include <stdlib.h>
void swap(int *x, int *y)
{
  int temp = *x;
  *x = *y;
  *y = temp;
}
void sortat(int p[], int at[], int bt[], int n)
{
  int i, j;
  for (i = 0; i < n; i++)
  {
    for (j = i + 1; j < n; j++)
    { /* sort the process having less arrival*/
      if (at[i] > at[j])
      {
        swap(&p[i], &p[j]);
        swap(&at[i], &at[j]);
        swap(&bt[i], &bt[j]);
      }
      /* if two processes have the same arrival time than sort them having less burst time */
      else if (at[i] == at[j])
      {
        if (bt[i] > bt[j])
          swap(&p[i], &p[j]);
        swap(&at[i], &at[j]);
        swap(&bt[i], &bt[j]);
      }
    }
  }
}
/* calculate turnaround time and waiting time */
void tatwt(int ct[], int at[], int bt[], int tat[], int wt[], int n)
{
  int i;
  for (i = 0; i < n; i++)
  {
    tat[i] = ct[i] - at[i];
    wt[i] = tat[i] - bt[i];
  }
}

void print_gantt_chart(int p[], int bt[], int ct[], int n)
{
  int i, j;

  // Print top bar
  printf(" ");
  for (i = 0; i < n; i++)
  {
    for (j = 0; j < bt[i]; j++)
      printf("--");
    printf(" ");
  }
  printf("\n|");

  // Print process IDs in the middle
  for (i = 0; i < n; i++)
  {
    for (j = 0; j < bt[i] - 1; j++)
      printf(" ");
    printf("P%d", p[i]);
    for (j = 0; j < bt[i] - 1; j++)
      printf(" ");
    printf("|");
  }
  printf("\n ");

  // Print bottom bar
  for (i = 0; i < n; i++)
  {
    for (j = 0; j < bt[i]; j++)
      printf("--");
    printf(" ");
  }
  printf("\n");

  // Print the timeline
  printf("0");
  for (i = 0; i < n; i++)
  {
    for (j = 0; j < bt[i]; j++)
      printf("  ");
    if (ct[i] > 9)
      printf("\b"); // Adjust for numbers > 9
    printf("%d", ct[i]);
  }
  printf("\n");
}

int main()
{
  int *p, *at, *bt, *tat, *wt, *ct, pos, i, j, min = 1000, n;
  float awt = 0, atat = 0;
  printf("\nenter the number of process:");
  scanf("%d", &n);
  p = (int *)malloc(n * sizeof(int));
  at = (int *)malloc(n * sizeof(int));
  bt = (int *)malloc(n * sizeof(int));
  ct = (int *)malloc(n * sizeof(int));
  wt = (int *)malloc(n * sizeof(int));
  tat = (int *)malloc(n * sizeof(int));
  printf("enter the process");
  for (i = 0; i < n; i++)
  {
    scanf("%d", &p[i]);
  }
  printf("enter the arrival time");
  for (i = 0; i < n; i++)
  {
    scanf("%d", &at[i]);
  }
  printf("enter the burst time");
  for (i = 0; i < n; i++)
  {
    scanf("%d", &bt[i]);
  }
  sortat(p, at, bt, n);
  ct[0] = at[0] + bt[0];
  for (i = 1; i < n; i++)
  {
    for (j = i; j < n; j++)
    {
      if (at[j] <= ct[i - 1])
      {
        if (bt[j] < min)
        {
          min = bt[j];
          pos = j;
        }
      }
    }
    swap(&p[i], &p[pos]);
    swap(&at[i], &at[pos]);
    swap(&bt[i], &bt[pos]);
    min = 1000;
    ct[i] = ct[i - 1] + bt[i];
  }
  tatwt(ct, at, bt, tat, wt, n);
  printf("\np\t at\t bt\t ct\t tat\t wt");
  for (i = 0; i < n; i++)
  {
    printf("\n%d\t %d\t %d\t %d\t %d\t %d", p[i], at[i], bt[i], ct[i], tat[i], wt[i]);
  }
  for (i = 0; i < n; i++)
  {
    atat += tat[i];
    awt += wt[i];
  }

  atat = atat / n;
  awt = awt / n;
  printf("\n avg tat=%.2f and avg wt=%.2f", atat, awt);
  printf("\n");

  print_gantt_chart(p, bt, ct, n);
  return 0;
}


sjp_primitive

#include <stdio.h>
#include <limits.h> // For INT_MAX

// Structure to store process information
struct Process {
    int id;             // Process ID
    int arrivalTime;     // Arrival time of the process
    int burstTime;       // Burst time (total)
    int remainingTime;   // Remaining time (for preemption)
    int completionTime;  // Completion time
    int waitingTime;     // Waiting time
    int turnaroundTime;  // Turnaround time
};

// Function to find the process with the shortest remaining time at the current time
int find_shortest_remaining_time(struct Process processes[], int n, int current_time) {
    int min_remaining_time = INT_MAX;
    int shortest_process_index = -1;

    for (int i = 0; i < n; i++) {
        if (processes[i].arrivalTime <= current_time && processes[i].remainingTime > 0) {
            if (processes[i].remainingTime < min_remaining_time) {
                min_remaining_time = processes[i].remainingTime;
                shortest_process_index = i;
            }
        }
    }

    return shortest_process_index;
}

void preemptive_sjf(struct Process processes[], int n) {
    int completed = 0, current_time = 0;
    int total_waiting_time = 0, total_turnaround_time = 0;
    
    // Variables for Gantt Chart
    int gantt_chart[100], gantt_time[100], gantt_counter = 0;

    // Until all processes are completed
    while (completed < n) {
        int shortest_process_index = find_shortest_remaining_time(processes, n, current_time);

        // If no process is available at the current time, move the time forward
        if (shortest_process_index == -1) {
            current_time++;
            continue;
        }

        // Store the process in Gantt chart sequence
        gantt_chart[gantt_counter] = processes[shortest_process_index].id;
        gantt_time[gantt_counter] = current_time;
        gantt_counter++;

        // Reduce remaining time of the selected process
        processes[shortest_process_index].remainingTime--;

        // If the process finishes execution
        if (processes[shortest_process_index].remainingTime == 0) {
            completed++;
            processes[shortest_process_index].completionTime = current_time + 1;
            processes[shortest_process_index].turnaroundTime = processes[shortest_process_index].completionTime - processes[shortest_process_index].arrivalTime;
            processes[shortest_process_index].waitingTime = processes[shortest_process_index].turnaroundTime - processes[shortest_process_index].burstTime;

            total_waiting_time += processes[shortest_process_index].waitingTime;
            total_turnaround_time += processes[shortest_process_index].turnaroundTime;
        }

        current_time++;
    }

    // Adding the final time for Gantt chart
    gantt_time[gantt_counter] = current_time;

    // Print process results
    printf("\nPID\tA.T\tB.T\tC.T\tTAT\tWT\n");
    for (int i = 0; i < n; i++) {
        printf("%d\t%d\t%d\t%d\t%d\t%d\n", processes[i].id, processes[i].arrivalTime, processes[i].burstTime,
               processes[i].completionTime, processes[i].turnaroundTime, processes[i].waitingTime);
    }

    // Calculate and display average turnaround time and waiting time
    float average_tat = (float)total_turnaround_time / n;
    float average_wt = (float)total_waiting_time / n;

    printf("\nAverage Turnaround Time: %.2f", average_tat);
    printf("\nAverage Waiting Time: %.2f\n", average_wt);

    // Print Gantt Chart
    printf("\nGantt Chart:\n");
    printf(" ");
    for (int i = 0; i < gantt_counter; i++) {
        printf("----");
    }
    printf("\n|");
    for (int i = 0; i < gantt_counter; i++) {
        printf(" P%d |", gantt_chart[i]);
    }
    printf("\n ");
    for (int i = 0; i < gantt_counter; i++) {
        printf("----");
    }
    printf("\n");
    for (int i = 0; i <= gantt_counter; i++) {
        printf("%2d  ", gantt_time[i]);
    }
    printf("\n");
}

int main() {
    int n;

    // Input number of processes
    printf("Enter the number of processes: ");
    scanf("%d", &n);

    struct Process processes[n];

    // Input process details
    for (int i = 0; i < n; i++) {
        printf("\nEnter details for Process %d\n", i + 1);
        processes[i].id = i + 1;
        printf("Arrival Time: ");
        scanf("%d", &processes[i].arrivalTime);
        printf("Burst Time: ");
        scanf("%d", &processes[i].burstTime);

        // Initialize remaining time to burst time
        processes[i].remainingTime = processes[i].burstTime;
    }

    // Call the preemptive SJF scheduling function
    preemptive_sjf(processes, n);

    return 0;
}
priority non primitive
#include <stdio.h>

// Function to print the Gantt chart
void print_gantt_chart(int p[], int bt[], int ct[], int n) {
    int i, j;

    // Print top bar
    printf(" ");
    for (i = 0; i < n; i++) {
        for (j = 0; j < bt[i]; j++) printf("--");
        printf(" ");
    }
    printf("\n|");

    // Print process IDs in the middle
    for (i = 0; i < n; i++) {
        for (j = 0; j < bt[i] - 1; j++) printf(" ");
        printf("P%d", p[i]);
        for (j = 0; j < bt[i] - 1; j++) printf(" ");
        printf("|");
    }
    printf("\n ");

    // Print bottom bar
    for (i = 0; i < n; i++) {
        for (j = 0; j < bt[i]; j++) printf("--");
        printf(" ");
    }
    printf("\n");

    // Print the timeline
    printf("0");
    for (i = 0; i < n; i++) {
        for (j = 0; j < bt[i]; j++) printf("  ");
        if (ct[i] > 9) printf("\b"); // Adjust for numbers > 9
        printf("%d", ct[i]);
    }
    printf("\n");
}

int main() { 
    int p[10], bt[10], wt[10], tat[10], ct[10], at[10];  
    int i, j, temp, n;
    float awt = 0, atat = 0;

    // Input number of processes
    printf("Enter number of processes: ");
    scanf("%d", &n);

    // Input process IDs
    printf("Enter %d process IDs: ", n);
    for (i = 0; i < n; i++) {
        scanf("%d", &p[i]);
    }

    // Input arrival times
    printf("Enter %d arrival times: ", n);
    for (i = 0; i < n; i++) {
        scanf("%d", &at[i]);
    }

    // Input burst times
    printf("Enter %d burst times: ", n);
    for (i = 0; i < n; i++) {
        scanf("%d", &bt[i]);
    }

    // Sort processes based on Arrival Time (AT)
    for (i = 0; i < n - 1; i++) {
        for (j = 0; j < n - i - 1; j++) {
            if (at[j] > at[j + 1]) {
                // Swap Arrival Time
                temp = at[j];
                at[j] = at[j + 1];
                at[j + 1] = temp;
                
                // Swap Burst Time
                temp = bt[j];
                bt[j] = bt[j + 1];
                bt[j + 1] = temp;
                
                // Swap Process ID
                temp = p[j];
                p[j] = p[j + 1];
                p[j + 1] = temp;
            }
        }
    }

    // Calculate Completion Times
    ct[0] = at[0] + bt[0];
    for (i = 1; i < n; i++) {
        int wait_time = (ct[i - 1] > at[i]) ? ct[i - 1] : at[i];
        ct[i] = wait_time + bt[i];
    }

    // Print the process table
    printf("\nPID\tA.T\tB.T\tC.T\tTAT\tWT");
    for (i = 0; i < n; i++) {
        tat[i] = ct[i] - at[i]; // Turnaround Time
        wt[i] = tat[i] - bt[i]; // Waiting Time
        atat += tat[i]; // Total Turnaround Time
        awt += wt[i];   // Total Waiting Time
        printf("\n%d\t%d\t%d\t%d\t%d\t%d", p[i], at[i], bt[i], ct[i], tat[i], wt[i]);
    }
    atat = atat / n; // Average Turnaround Time
    awt = awt / n;   // Average Waiting Time

    // Print Average Turnaround Time and Average Waiting Time
    printf("\n\nAverage Turnaround Time: %.2f", atat);
    printf("\nAverage Waiting Time: %.2f\n", awt);

    // Print the Gantt chart
    print_gantt_chart(p, bt, ct, n);

    return 0;
}
priority primitive 


#include <stdio.h>
#include <limits.h>

// Structure for storing process information
struct Process {
    int id;
    int burstTime;
    int remainingTime;
    int arrivalTime;
    int priority;
    int completionTime;
    int waitingTime;
    int turnaroundTime;
};

// Function to find the process with the highest priority (preemptive)
int find_highest_priority(struct Process processes[], int n, int current_time) {
    int highest_priority_index = -1;
    int highest_priority = INT_MAX;

    for (int i = 0; i < n; i++) {
        if (processes[i].arrivalTime <= current_time && processes[i].remainingTime > 0) {
            if (processes[i].priority < highest_priority || 
                (processes[i].priority == highest_priority && processes[i].arrivalTime < processes[highest_priority_index].arrivalTime)) {
                highest_priority = processes[i].priority;
                highest_priority_index = i;
            }
        }
    }

    return highest_priority_index;
}

// Function to implement preemptive priority scheduling
void preemptive_priority_scheduling(struct Process processes[], int n) {
    int completed = 0, current_time = 0;
    int total_turnaround_time = 0, total_waiting_time = 0;

    // Gantt chart timeline
    printf("\nGantt Chart:\n");

    // Until all processes are completed
    while (completed < n) {
        int highest_priority_index = find_highest_priority(processes, n, current_time);

        // If no process is available at the current time, move time forward
        if (highest_priority_index == -1) {
            current_time++;
            continue;
        }

        // Print process execution in Gantt Chart
        printf("| P%d ", processes[highest_priority_index].id);

        // Execute the process for 1 unit of time (preemption occurs every 1 unit)
        processes[highest_priority_index].remainingTime--;
        current_time++;

        // If the process is completed
        if (processes[highest_priority_index].remainingTime == 0) {
            completed++;
            processes[highest_priority_index].completionTime = current_time;
            processes[highest_priority_index].turnaroundTime = processes[highest_priority_index].completionTime - processes[highest_priority_index].arrivalTime;
            processes[highest_priority_index].waitingTime = processes[highest_priority_index].turnaroundTime - processes[highest_priority_index].burstTime;

            // Accumulate total turnaround and waiting times
            total_turnaround_time += processes[highest_priority_index].turnaroundTime;
            total_waiting_time += processes[highest_priority_index].waitingTime;
        }
    }
    printf("|\n");

    // Calculate and display the process table
    printf("\nPID\tA.T\tB.T\tPrio\tC.T\tTAT\tWT");
    for (int i = 0; i < n; i++) {
        printf("\n%d\t%d\t%d\t%d\t%d\t%d\t%d", processes[i].id, processes[i].arrivalTime, processes[i].burstTime, 
               processes[i].priority, processes[i].completionTime, processes[i].turnaroundTime, processes[i].waitingTime);
    }

    // Calculate average turnaround time and waiting time
    float average_tat = (float)total_turnaround_time / n;
    float average_wt = (float)total_waiting_time / n;

    printf("\n\nAverage Turnaround Time: %.2f", average_tat);
    printf("\nAverage Waiting Time: %.2f\n", average_wt);
}

int main() {
    int n;

    // Input number of processes
    printf("Enter the number of processes: ");
    scanf("%d", &n);

    struct Process processes[n];

    // Input process details
    for (int i = 0; i < n; i++) {
        printf("\nEnter details for Process %d\n", i + 1);
        processes[i].id = i + 1;
        printf("Arrival Time: ");
        scanf("%d", &processes[i].arrivalTime);
        printf("Burst Time: ");
        scanf("%d", &processes[i].burstTime);
        printf("Priority (lower number = higher priority): ");
        scanf("%d", &processes[i].priority);

        // Initialize remaining time and other parameters
        processes[i].remainingTime = processes[i].burstTime;
    }

    // Execute preemptive priority scheduling
    preemptive_priority_scheduling(processes, n);

    return 0;
}




round robin 
#include <stdio.h>
#include <stdlib.h>

struct Process
{
    int pid;
    int burst_time;
    int arrival_time;
    int waiting_time;
    int turnaround_time;
    int remaining_time;
    int start_time;
};

// Function to display the Gantt chart
void displayGanttChart(int *process_sequence, int *time_sequence, int sequence_length)
{
    printf("\nGantt Chart:\n");
    printf("+");
    for (int i = 0; i < sequence_length; i++)
        printf("------+");

    printf("\n|");
    for (int i = 0; i < sequence_length; i++)
        printf("  P%d  |", process_sequence[i]);

    printf("\n+");
    for (int i = 0; i < sequence_length; i++)
        printf("------+");

    printf("\n0");
    for (int i = 0; i < sequence_length; i++)
        printf("%6d", time_sequence[i]);
    printf("\n");
}

// Function to display results: waiting time, turnaround time, and averages
void displayResults(struct Process *processes, int n)
{
    float avg_waiting_time = 0, avg_turnaround_time = 0;

    printf("\nPID\tBurst Time\tWaiting Time\tTurnaround Time\n");
    for (int i = 0; i < n; i++)
    {
        printf("%d\t%d\t\t%d\t\t%d\n",
               processes[i].pid,
               processes[i].burst_time,
               processes[i].waiting_time,
               processes[i].turnaround_time);

        avg_waiting_time += processes[i].waiting_time;
        avg_turnaround_time += processes[i].turnaround_time;
    }

    avg_waiting_time /= n;
    avg_turnaround_time /= n;

    printf("\nAverage Waiting Time: %.2f", avg_waiting_time);
    printf("\nAverage Turnaround Time: %.2f\n", avg_turnaround_time);
}

// Round Robin Scheduling function
void roundRobinScheduling(struct Process *processes, int n, int quantum)
{
    int process_sequence[100]; // Sequence of processes for Gantt chart
    int time_sequence[100];    // Corresponding time sequence for Gantt chart
    int sequence_length = 0;
    int remaining_time[n];
    int current_time = 0;
    int completed = 0;

    for (int i = 0; i < n; i++)
    {
        remaining_time[i] = processes[i].burst_time;
        processes[i].start_time = -1; // Initialize start time to -1 (not yet started)
    }

    while (completed != n)
    {
        int done = 1;
        for (int i = 0; i < n; i++)
        {
            if (remaining_time[i] > 0)
            {
                done = 0;

                // If remaining time is more than quantum
                if (remaining_time[i] > quantum)
                {
                    if (processes[i].start_time == -1)
                    {
                        processes[i].start_time = current_time; // Mark start time for the first time
                    }
                    current_time += quantum;
                    remaining_time[i] -= quantum;

                    // Record this in Gantt chart
                    process_sequence[sequence_length] = processes[i].pid;
                    time_sequence[sequence_length] = current_time;
                    sequence_length++;
                }
                // If remaining time is less or equal to quantum
                else
                {
                    if (processes[i].start_time == -1)
                    {
                        processes[i].start_time = current_time; // Mark start time for the first time
                    }
                    current_time += remaining_time[i];
                    processes[i].waiting_time = current_time - processes[i].burst_time - processes[i].arrival_time;

                    // Record this in Gantt chart
                    process_sequence[sequence_length] = processes[i].pid;
                    time_sequence[sequence_length] = current_time;
                    sequence_length++;

                    remaining_time[i] = 0;
                    completed++;

                    processes[i].turnaround_time = current_time - processes[i].arrival_time;
                }
            }
        }

        // If no process is active, time increments
        if (done == 1)
            break;
    }

    printf("\n--- Round Robin Scheduling ---\n");
    displayResults(processes, n);
    displayGanttChart(process_sequence, time_sequence, sequence_length);
}

int main()
{
    int n, quantum;

    printf("Enter number of processes: ");
    scanf("%d", &n);

    struct Process *processes = malloc(n * sizeof(struct Process));

    for (int i = 0; i < n; i++)
    {
        processes[i].pid = i + 1;
        printf("Enter burst time for process %d: ", i + 1);
        scanf("%d", &processes[i].burst_time);
        printf("Enter arrival time for process %d: ", i + 1);
        scanf("%d", &processes[i].arrival_time);
    }

    printf("Enter time quantum: ");
    scanf("%d", &quantum);

    roundRobinScheduling(processes, n, quantum);

    free(processes);
    return 0;
}


dining philosopher


#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>
#include <unistd.h>

#define NUM_PHILOSOPHERS 5
#define MEALS_TO_EAT 3 // Number of meals each philosopher should eat before termination

pthread_mutex_t mutex[NUM_PHILOSOPHERS];  // Mutex for each philosopher's fork
pthread_t philosophers[NUM_PHILOSOPHERS]; // Philosopher threads
int meals_eaten[NUM_PHILOSOPHERS] = {0};  // Track the number of meals each philosopher has eaten

// Function for philosophers to think, pick up forks, and eat
void *philosopher(void *num)
{
    int id = *((int *)num);

    while (meals_eaten[id] < MEALS_TO_EAT)
    { // Philosophers stop after MEALS_TO_EAT
        printf("Philosopher %d is thinking.\n", id);

        // Simulate thinking by sleeping
        sleep(rand() % 3 + 1);

        // Pick up the left fork (mutex[id])
        pthread_mutex_lock(&mutex[id]);
        printf("Philosopher %d picked up left fork %d.\n", id, id);

        // Pick up the right fork (mutex[(id+1) % NUM_PHILOSOPHERS])
        pthread_mutex_lock(&mutex[(id + 1) % NUM_PHILOSOPHERS]);
        printf("Philosopher %d picked up right fork %d.\n", id, (id + 1) % NUM_PHILOSOPHERS);

        // Eating
        printf("Philosopher %d is eating.\n", id);
        sleep(rand() % 3 + 1); // Simulate the time taken to eat

        // Increment the number of meals eaten
        meals_eaten[id]++;
        printf("Philosopher %d has eaten %d meals.\n", id, meals_eaten[id]);

        // Put down the right fork
        pthread_mutex_unlock(&mutex[(id + 1) % NUM_PHILOSOPHERS]);
        printf("Philosopher %d put down right fork %d.\n", id, (id + 1) % NUM_PHILOSOPHERS);

        // Put down the left fork
        pthread_mutex_unlock(&mutex[id]);
        printf("Philosopher %d put down left fork %d.\n", id, id);
    }

    printf("Philosopher %d has finished eating %d meals and is done.\n", id, MEALS_TO_EAT);
    return NULL;
}

int main()
{
    // Initialize mutexes for each philosopher's fork
    for (int i = 0; i < NUM_PHILOSOPHERS; i++)
    {
        pthread_mutex_init(&mutex[i], NULL);
    }

    // Create philosopher threads
    int ids[NUM_PHILOSOPHERS];
    for (int i = 0; i < NUM_PHILOSOPHERS; i++)
    {
        ids[i] = i;
        pthread_create(&philosophers[i], NULL, philosopher, (void *)&ids[i]);
    }

    // Wait for all philosopher threads to finish
    for (int i = 0; i < NUM_PHILOSOPHERS; i++)
    {
        pthread_join(philosophers[i], NULL);
    }

    // Destroy mutexes
    for (int i = 0; i < NUM_PHILOSOPHERS; i++)
    {
        pthread_mutex_destroy(&mutex[i]);
    }

    return 0;
}


bankers 

#include <stdio.h>
#include <stdbool.h>

#define MAX_PROCESSES 10
#define MAX_RESOURCES 5

// Function to check if the system is in a safe state
bool isSafe(int available[], int max[][MAX_RESOURCES], int allocation[][MAX_RESOURCES], int need[][MAX_RESOURCES], int num_processes, int num_resources)
{
    int work[MAX_RESOURCES];
    bool finish[MAX_PROCESSES] = {false};
    int safeSequence[MAX_PROCESSES];
    int count = 0;

    // Copy the available resources to work
    for (int i = 0; i < num_resources; i++)
    {
        work[i] = available[i];
    }

    // Find a process that can be safely executed
    while (count < num_processes)
    {
        bool found = false;
        for (int i = 0; i < num_processes; i++)
        {
            if (!finish[i])
            {
                int j;
                // Check if the process can be executed with available resources
                for (j = 0; j < num_resources; j++)
                {
                    if (need[i][j] > work[j])
                    {
                        break;
                    }
                }

                // If all needs can be satisfied
                if (j == num_resources)
                {
                    for (int k = 0; k < num_resources; k++)
                    {
                        work[k] += allocation[i][k];
                    }
                    safeSequence[count++] = i;
                    finish[i] = true;
                    found = true;
                }
            }
        }

        // If no process was found, system is not in a safe state
        if (!found)
        {
            printf("System is not in a safe state!\n");
            return false;
        }
    }

    // System is in a safe state
    printf("System is in a safe state.\nSafe sequence is: ");
    for (int i = 0; i < num_processes; i++)
    {
        printf("%d ", safeSequence[i]);
    }
    printf("\n");
    return true;
}

int main()
{
    int num_processes, num_resources;
    int available[MAX_RESOURCES];
    int max[MAX_PROCESSES][MAX_RESOURCES];
    int allocation[MAX_PROCESSES][MAX_RESOURCES];
    int need[MAX_PROCESSES][MAX_RESOURCES];

    // Input number of processes and resources
    printf("Enter the number of processes: ");
    scanf("%d", &num_processes);
    printf("Enter the number of resources: ");
    scanf("%d", &num_resources);

    // Input available resources
    printf("Enter the available resources:\n");
    for (int i = 0; i < num_resources; i++)
    {
        scanf("%d", &available[i]);
    }

    // Input max demand of each process
    printf("Enter the maximum demand of each process:\n");
    for (int i = 0; i < num_processes; i++)
    {
        printf("Process %d:\n", i);
        for (int j = 0; j < num_resources; j++)
        {
            scanf("%d", &max[i][j]);
        }
    }

    // Input allocated resources for each process
    printf("Enter the allocation of resources for each process:\n");
    for (int i = 0; i < num_processes; i++)
    {
        printf("Process %d:\n", i);
        for (int j = 0; j < num_resources; j++)
        {
            scanf("%d", &allocation[i][j]);
        }
    }

    // Calculate the need matrix
    for (int i = 0; i < num_processes; i++)
    {
        for (int j = 0; j < num_resources; j++)
        {
            need[i][j] = max[i][j] - allocation[i][j];
        }
    }

    // Check if the system is in a safe state
    isSafe(available, max, allocation, need, num_processes, num_resources);

    return 0;
}
FIFO 

#include<stdio.h> 
int main()
{
    int incomingStream[] = {7, 0, 1, 2, 0, 3, 0, 4, 2, 3, 0, 3, 2, 1, 2, 0};
    int pageFaults = 0;
    int frames = 3;
    int m, n, s, pages;

    pages = sizeof(incomingStream)/sizeof(incomingStream[0]);

    printf("Incoming \t Frame 1 \t Frame 2 \t Frame 3");
    int temp[frames];
    for(m = 0; m < frames; m++)
    {
        temp[m] = -1;
    }

    for(m = 0; m < pages; m++)
    {
        s = 0;

        for(n = 0; n < frames; n++)
        {
            if(incomingStream[m] == temp[n])
            {
                s++;
                pageFaults--;
            }
        }
        pageFaults++;
        
        if((pageFaults <= frames) && (s == 0))
        {
            temp[m] = incomingStream[m];
        }
        else if(s == 0)
        {
            temp[(pageFaults - 1) % frames] = incomingStream[m];
        }
      
        printf("\n");
        printf("%d\t",incomingStream[m]);
        for(n = 0; n < frames; n++)
        {
            if(temp[n] != -1)
                printf(" %d\t", temp[n]);
            else
                printf(" - \t");
        }
    }

    printf("\nTotal Page Faults:\t%d\n", pageFaults);
    return 0;
}

LRU

#include<stdio.h>
#include<limits.h>

int checkHit(int incomingPage, int queue[], int occupied){
    
    for(int i = 0; i < occupied; i++){
        if(incomingPage == queue[i])
            return 1;
    }
    
    return 0;
}

void printFrame(int queue[], int occupied)
{
    for(int i = 0; i < occupied; i++)
        printf("%d\t\t\t",queue[i]);
}

int main()
{

    int incomingStream[] = {7, 0, 1, 2, 0, 3, 0, 4, 2, 3, 0, 3, 2, 1, 2, 0, 1, 7, 0, 1};
//    int incomingStream[] = {1, 2, 3, 2, 1, 5, 2, 1, 6, 2, 5, 6, 3, 1, 3, 6, 1, 2, 4, 3};
//   int incomingStream[] = {1, 2, 3, 2, 1, 5, 2, 1, 6, 2, 5, 6, 3, 1, 3};
    
    int n = sizeof(incomingStream)/sizeof(incomingStream[0]);
    int frames = 4;
    int queue[n];
    int distance[n];
    int occupied = 0;
    int pagefault = 0;
    
    printf("Page\t Frame1 \t Frame2 \t Frame3\n");
    
    for(int i = 0;i < n; i++)
    {
        printf("%d:  \t\t",incomingStream[i]);
        if(checkHit(incomingStream[i], queue, occupied)){
            printFrame(queue, occupied);
        }
        
        else if(occupied < frames){
            queue[occupied] = incomingStream[i];
            pagefault++;
            occupied++;
            
            printFrame(queue, occupied);
        }
        else{
            
            int max = INT_MIN;
            int index;
           for (int j = 0; j < frames; j++)
            {
                distance[j] = 0;
                for(int k = i - 1; k >= 0; k--)
                {
                    ++distance[j];

                    if(queue[j] == incomingStream[k])
                        break;
                }
                
                if(distance[j] > max){
                    max = distance[j];
                    index = j;
                }
            }
            queue[index] = incomingStream[i];
            printFrame(queue, occupied);
            pagefault++;
        }
        
        printf("\n");
    }
    
    printf("Page Fault: %d",pagefault);
    
    return 0;
}

OPT

#include <stdio.h>
  
int search(int key, int frame_items[], int frame_occupied)
{
    for (int i = 0; i < frame_occupied; i++)
        if (frame_items[i] == key)
            return 1;
    return 0;
}

void printOuterStructure(int max_frames){
    printf("Stream ");
    
    for(int i = 0; i < max_frames; i++)
        printf("Frame%d ", i+1);
}
void printCurrFrames(int item, int frame_items[], int frame_occupied, int max_frames){
    
    printf("\n%d \t\t", item);
    
    for(int i = 0; i < max_frames; i++){
        if(i < frame_occupied)
            printf("%d \t\t", frame_items[i]);
        else
            printf("- \t\t");
    }
}
int predict(int ref_str[], int frame_items[], int refStrLen, int index, int frame_occupied)
{
    int result = -1, farthest = index;
    for (int i = 0; i < frame_occupied; i++) {
        int j;
        for (j = index; j < refStrLen; j++) 
        { 
            if (frame_items[i] == ref_str[j]) 
            { 
                if (j > farthest) {
                    farthest = j;
                    result = i;
                }
                break;
            }
        }
  
        if (j == refStrLen)
            return i;
    }
  
    return (result == -1) ? 0 : result;
}
  
void optimalPage(int ref_str[], int refStrLen, int frame_items[], int max_frames)
{
    int frame_occupied = 0;
    printOuterStructure(max_frames);
    
    int hits = 0;
    for (int i = 0; i < refStrLen; i++) {
  
        if (search(ref_str[i], frame_items, frame_occupied)) {
            hits++;
            printCurrFrames(ref_str[i], frame_items, frame_occupied, max_frames);
            continue;
        }
  
        if (frame_occupied < max_frames){
            frame_items[frame_occupied] = ref_str[i];
            frame_occupied++;
            printCurrFrames(ref_str[i], frame_items, frame_occupied, max_frames);
        }
        else {
            int pos = predict(ref_str, frame_items, refStrLen, i + 1, frame_occupied);
            frame_items[pos] = ref_str[i];
            printCurrFrames(ref_str[i], frame_items, frame_occupied, max_frames);
        }
        
    }
    printf("\n\nHits: %d\n", hits);
    printf("Misses: %d", refStrLen - hits);
}
  
int main()
{
    // int ref_str[] = {9, 0, 5, 1, 0, 3, 0, 4, 1, 3, 0, 3, 1, 3};
    int ref_str[] = {7, 0, 1, 2, 0, 3, 0, 4, 2, 3, 0, 3, 2, 1, 2, 0, 1, 7, 0, 1};
    int refStrLen = sizeof(ref_str) / sizeof(ref_str[0]);
    int max_frames = 4;
    int frame_items[max_frames];
    
    optimalPage(ref_str, refStrLen, frame_items, max_frames);
    return 0;
}

