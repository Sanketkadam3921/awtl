1. Write a Program to implement DDA Line drawing algorithm.

#include <stdio.h>
#include <conio.h>
#include <graphics.h>

void drawLineDDA(int x1, int y1, int x2, int y2) {
    int dx = x2 - x1;
    int dy = y2 - y1;
    int steps,k;
    float xIncrement, yIncrement, x = x1, y = y1;

    if (abs(dx) > abs(dy)) {
	steps = abs(dx);
    } else {
	steps = abs(dy);
    }

    xIncrement = (float) dx / steps;
    yIncrement = (float) dy / steps;

    putpixel(x, y, WHITE);

    for (k = 0; k < steps; k++) {
        x += xIncrement;
        y += yIncrement;
        putpixel((int)(x + 0.5), (int)(y + 0.5), WHITE);
    }
}

int main() {
     int x1, y1, x2, y2;
    int gd = DETECT, gm;
    initgraph(&gd, &gm, "C:\\TURBOC3\\BGI");


    printf("Enter coordinates of first point (x1, y1): ");
    scanf("%d %d", &x1, &y1);
    printf("Enter coordinates of second point (x2, y2): ");
    scanf("%d %d", &x2, &y2);

    drawLineDDA(x1, y1, x2, y2);

    getch();
    closegraph();
    return 0;
}


//150 100
//100 150

------------------------------------------------------------------------------------------------------------------------------------------

2. Write a Program to implement Bresenham’s Line drawing algorithm.

#include <stdio.h>
#include <conio.h>
#include <graphics.h>

void drawLineBresenham(int x1, int y1, int x2, int y2) {
    int dx = abs(x2 - x1);
    int dy = abs(y2 - y1);
    int x, y, p, incrx, incry, i;

    x = x1;
    y = y1;

    if (x2 > x1) {
        incrx = 1;
    } else {
        incrx = -1;
    }

    if (y2 > y1) {
        incry = 1;
    } else {
        incry = -1;
    }

    if (dx > dy) {
        putpixel(x, y, WHITE);
        p = 2 * dy - dx;
        for (i = 0; i < dx; i++) {
            if (p >= 0) {
                y += incry;
                p += 2 * (dy - dx);
            } else {
                p += 2 * dy;
            }
            x += incrx;
            putpixel(x, y, WHITE);
        }
    } else {
        putpixel(x, y, WHITE);
        p = 2 * dx - dy;
        for (i = 0; i < dy; i++) {
            if (p >= 0) {
                x += incrx;
                p += 2 * (dx - dy);
            } else {
                p += 2 * dx;
            }
            y += incry;
            putpixel(x, y, WHITE);
        }
    }
}

int main() {
    int x1, y1, x2, y2;
    int gd = DETECT, gm;
    initgraph(&gd, &gm, "C:\\TURBOC3\\BGI");


    printf("Enter coordinates of first point (x1, y1): ");
    scanf("%d %d", &x1, &y1);
    printf("Enter coordinates of second point (x2, y2): ");
    scanf("%d %d", &x2, &y2);

    drawLineBresenham(x1, y1, x2, y2);

    getch();
    closegraph();
    return 0;
}

//300 100
//150 100

------------------------------------------------------------------------------------------------------------------------------------------

3. Write a Program to implement Bresenham’s Circle drawing algorithm.

#include <stdio.h>
#include <conio.h>
#include <graphics.h>

void drawCircleBresenham(int xc, int yc, int radius) {
    int x = 0, y = radius;
    int d = 3 - 2 * radius;

    while (x <= y) {
	putpixel(xc + x, yc + y, WHITE);
	putpixel(xc - x, yc + y, WHITE);
	putpixel(xc + x, yc - y, WHITE);
	putpixel(xc - x, yc - y, WHITE);
	putpixel(xc + y, yc + x, WHITE);
	putpixel(xc - y, yc + x, WHITE);
	putpixel(xc + y, yc - x, WHITE);
	putpixel(xc - y, yc - x, WHITE);

	if (d <= 0) {
	    d = d + 4 * x + 6;
	} else {
	    d = d + 4 * (x - y) + 10;
	    y--;
	}
	x++;
    }
}

int main() {
    int xc, yc, radius;
    int gd = DETECT, gm;
    initgraph(&gd, &gm, "C:\\TURBOC3\\BGI");


    printf("Enter coordinates of center (xc, yc): ");
    scanf("%d %d", &xc, &yc);
    printf("Enter radius of circle: ");
    scanf("%d", &radius);

    drawCircleBresenham(xc, yc, radius);

    getch();
    closegraph();
    return 0;
}

//300 200
//50

------------------------------------------------------------------------------------------------------------------------------------------

4. Write a Program to implement Mid-point Circle drawing algorithm.

#include <stdio.h>
#include <conio.h>
#include <graphics.h>

void drawCircleMidPoint(int xc, int yc, int radius) {
    int x = 0, y = radius;
    int p = 1 - radius;

    putpixel(xc + x, yc + y, WHITE);
    putpixel(xc - x, yc + y, WHITE);
    putpixel(xc + x, yc - y, WHITE);
    putpixel(xc - x, yc - y, WHITE);
    putpixel(xc + y, yc + x, WHITE);
    putpixel(xc - y, yc + x, WHITE);
    putpixel(xc + y, yc - x, WHITE);
    putpixel(xc - y, yc - x, WHITE);

    while (x < y) {
        x++;
        if (p < 0) {
            p += 2 * x + 1;
        } else {
            y--;
            p += 2 * (x - y) + 1;
        }
        putpixel(xc + x, yc + y, WHITE);
        putpixel(xc - x, yc + y, WHITE);
        putpixel(xc + x, yc - y, WHITE);
        putpixel(xc - x, yc - y, WHITE);
        putpixel(xc + y, yc + x, WHITE);
        putpixel(xc - y, yc + x, WHITE);
        putpixel(xc + y, yc - x, WHITE);
        putpixel(xc - y, yc - x, WHITE);
    }
}

int main() {
    int xc, yc, radius;
    int gd = DETECT, gm;
    initgraph(&gd, &gm, "C:\\TURBOC3\\BGI");

    printf("Enter coordinates of center (xc, yc): ");
    scanf("%d %d", &xc, &yc);
    printf("Enter radius of circle: ");
    scanf("%d", &radius);

    drawCircleMidPoint(xc, yc, radius);

    getch();
    closegraph();
    return 0;
}
//300 200
//50

------------------------------------------------------------------------------------------------------------------------------------------

5. Write a Program to draw a face of Teddy bear using midpoint algorithm only.

#include <stdio.h>
#include <conio.h>
#include <graphics.h>

void drawCircleMidPoint(int xc, int yc, int radius) {
    int x = 0, y = radius;
    int p = 1 - radius;

    putpixel(xc + x, yc + y, WHITE);
    putpixel(xc - x, yc + y, WHITE);
    putpixel(xc + x, yc - y, WHITE);
    putpixel(xc - x, yc - y, WHITE);
    putpixel(xc + y, yc + x, WHITE);
    putpixel(xc - y, yc + x, WHITE);
    putpixel(xc + y, yc - x, WHITE);
    putpixel(xc - y, yc - x, WHITE);

    while (x < y) {
        x++;
        if (p < 0) {
            p += 2 * x + 1;
        } else {
            y--;
            p += 2 * (x - y) + 1;
        }
        putpixel(xc + x, yc + y, WHITE);
        putpixel(xc - x, yc + y, WHITE);
        putpixel(xc + x, yc - y, WHITE);
        putpixel(xc - x, yc - y, WHITE);
        putpixel(xc + y, yc + x, WHITE);
        putpixel(xc - y, yc + x, WHITE);
        putpixel(xc + y, yc - x, WHITE);
        putpixel(xc - y, yc - x, WHITE);
    }
}

void drawTeddyBear(int xc, int yc, int radius) {
    // Head
    drawCircleMidPoint(xc, yc, radius);

    // Eyes
    drawCircleMidPoint(xc - radius / 4, yc - radius / 4, radius / 10); // Left eye
    drawCircleMidPoint(xc + radius / 4, yc - radius / 4, radius / 10); // Right eye

    // Nose (triangle)
    line(xc, yc, xc - radius / 10, yc + radius / 5);
    line(xc, yc, xc + radius / 10, yc + radius / 5);
    line(xc - radius / 10, yc + radius / 5, xc + radius / 10, yc + radius / 5);

    // Mouth (arc)
    arc(xc, yc + radius / 4, 180, 360, radius / 4);
}

int main() {
    int xc, yc, radius;
    int gd = DETECT, gm;
    initgraph(&gd, &gm, "C:\\TURBOC3\\BGI");

    printf("Enter the coordinates of the center (x y): ");
    scanf("%d %d", &xc, &yc);

    printf("Enter the radius of the teddy bear's face: ");
    scanf("%d", &radius);

    drawTeddyBear(xc, yc, radius);

    getch();
    closegraph();
    return 0;
}

//350 240
//60

------------------------------------------------------------------------------------------------------------------------------------------

6. Write a Program to draw a car using Bresenham’s algorithm only.

#include <graphics.h>
#include <conio.h>
#include <math.h>

void bresenhamLine(int x1, int y1, int x2, int y2) {
    int dx = abs(x2 - x1);
int dy = abs(y2 - y1);
int sx = x1 < x2 ? 1 : -1;
int sy = y1 < y2 ? 1 : -1;
int err = dx - dy;
while (1) {
int e2;
putpixel(x1, y1, WHITE);
if (x1 == x2 && y1 == y2) break;
e2 = 2 * err;
if (e2 > -dy) { err -= dy; x1 += sx; }
if (e2 < dx) { err += dx; y1 += sy; }
}
}


// Function to draw a circle using Bresenham's Algorithm
void bresenhamCircle(int xc, int yc, int r) {
    int x = 0, y = r;
    int d = 3 - 2 * r;

    while (y >= x) {
        // For each pixel we draw all eight pixels
        putpixel(xc + x, yc + y, WHITE);
        putpixel(xc - x, yc + y, WHITE);
        putpixel(xc + x, yc - y, WHITE);
        putpixel(xc - x, yc - y, WHITE);
        putpixel(xc + y, yc + x, WHITE);
        putpixel(xc - y, yc + x, WHITE);
        putpixel(xc + y, yc - x, WHITE);
        putpixel(xc - y, yc - x, WHITE);
        x++;
        if (d > 0) {
            y--;
            d = d + 4 * (x - y) + 10;
        } else {
            d = d + 4 * x + 6;
        }
    }
}

int main() {
    int gd = DETECT, gm;
    initgraph(&gd, &gm, "C:\\Turboc3\\BGI");

     bresenhamLine(90,150,150,150);
    bresenhamCircle(160,150,8);
    bresenhamCircle(160,150,2);

    bresenhamLine(170,150,210,150);
    bresenhamCircle(220,150,8);
    bresenhamCircle(220,150,2);
    bresenhamLine(230,150,280,150);
    bresenhamLine(280,150,280,110);
    bresenhamLine(280,110,230,110);
    bresenhamLine(230,110,200,90);
    bresenhamLine(200,90,160,90);
    bresenhamLine(160,90,130,110);
    bresenhamLine(130,110,90,110);
    bresenhamLine(90,110,90,150);

   

    //window
    bresenhamLine(162,92,135,110);
    bresenhamLine(135,110,226,110);
    bresenhamLine(162,92,198,92);
    bresenhamLine(180,110,180,92);
    bresenhamLine(226,110,198,92);


    getch();
    closegraph();
    return 0;
}

------------------------------------------------------------------------------------------------------------------------------------------

7. Write a Program to implement Flood fill algorithm for a convex polygon. Draw polygon edges by DDA / Bresenham line algorithm.

#include <graphics.h>
#include <conio.h>

// Function to implement Bresenham's Line Drawing Algorithm
void bresenhamLine(int x1, int y1, int x2, int y2) {
 int dx = abs(x2 - x1);
int dy = abs(y2 - y1);
int sx = x1 < x2 ? 1 : -1;
int sy = y1 < y2 ? 1 : -1;
int err = dx - dy;
while (1) {
int e2;
putpixel(x1, y1, WHITE);
if (x1 == x2 && y1 == y2) break;
e2 = 2 * err;
if (e2 > -dy) { err -= dy; x1 += sx; }
if (e2 < dx) { err += dx; y1 += sy; }
}
}


// Function to implement the Flood Fill Algorithm
void floodFill(int x, int y, int fillColor, int bgColor) {
    if (getpixel(x, y) == bgColor) {
        putpixel(x, y, fillColor);
        floodFill(x + 1, y, fillColor, bgColor);
        floodFill(x - 1, y, fillColor, bgColor);
        floodFill(x, y + 1, fillColor, bgColor);
        floodFill(x, y - 1, fillColor, bgColor);
    }
}

int main() {
    int gd = DETECT, gm,i;
 int poly[10] = {150, 140, 170, 140, 180, 160, 160, 180, 150, 140};
    initgraph(&gd, &gm, "C:\\Turboc3\\BGI");

    

    // Draw the polygon using Bresenham's line algorithm
     for (i = 0; i < 8; i += 2) {
        bresenhamLine(poly[i], poly[i + 1], poly[i + 2], poly[i + 3]);
    }

     floodFill(160, 160, YELLOW, BLACK);

    getch();
    closegraph();
    return 0;
}

------------------------------------------------------------------------------------------------------------------------------------------

8. Write a Program to implement Boundary fill algorithm for a convex polygon. Draw polygon edges by DDA / Bresenham line algorithm.

#include <graphics.h>
#include <conio.h>

// Function to implement Bresenham's Line Drawing Algorithm
void bresenhamLine(int x1, int y1, int x2, int y2) {
    int dx = abs(x2 - x1);
int dy = abs(y2 - y1);
int sx = x1 < x2 ? 1 : -1;
int sy = y1 < y2 ? 1 : -1;
int err = dx - dy;
while (1) {
int e2;
putpixel(x1, y1, WHITE);
if (x1 == x2 && y1 == y2) break;
e2 = 2 * err;
if (e2 > -dy) { err -= dy; x1 += sx; }
if (e2 < dx) { err += dx; y1 += sy; }
}
}

// Function to implement the Boundary Fill Algorithm
void boundaryFill(int x, int y, int fillColor, int boundaryColor) {
    int current = getpixel(x, y);
    if (current != boundaryColor && current != fillColor) {
        putpixel(x, y, fillColor);
        boundaryFill(x + 1, y, fillColor, boundaryColor);
        boundaryFill(x - 1, y, fillColor, boundaryColor);
        boundaryFill(x, y + 1, fillColor, boundaryColor);
        boundaryFill(x, y - 1, fillColor, boundaryColor);
    }
}

int main() {
    int gd = DETECT, gm,i;
    int poly[10] = {150, 140, 170, 140, 180, 160, 160, 180, 150, 140};
    initgraph(&gd, &gm, "C:\\Turboc3\\BGI");




    
    for (i = 0; i < 8; i += 2) {
        bresenhamLine(poly[i], poly[i + 1], poly[i + 2], poly[i + 3]);
    }

    
    boundaryFill(160, 160, GREEN, WHITE);

    getch();
    closegraph();
    return 0;
}

------------------------------------------------------------------------------------------------------------------------------------------

9. Write a Program to implement Fence fill algorithm for a concave polygon. Draw polygon edges by DDA / Bresenham line algorithm.

#include <graphics.h>
#include <conio.h>
#include <math.h>

// Function to implement Bresenham's Line Drawing Algorithm
void bresenhamLine(int x1, int y1, int x2, int y2) {
    int dx = abs(x2 - x1);
    int dy = abs(y2 - y1);
    int sx = x1 < x2 ? 1 : -1;
    int sy = y1 < y2 ? 1 : -1;
    int err = dx - dy,e2;

    while (1) {
	putpixel(x1, y1, WHITE);
	if (x1 == x2 && y1 == y2) break;
	e2 = 2 * err;
	if (e2 > -dy) { err -= dy; x1 += sx; }
	if (e2 < dx) { err += dx; y1 += sy; }
    }
}

// Function to implement the Fence Fill Algorithm
void fenceFill(int *points, int numEdges, int fillColor) {
    int i, j, temp, x1, y1, x2, y2, minX, maxX, minY, maxY;



    // Find bounding box of the polygon
    minX = maxX = points[0];
    minY = maxY = points[1];
    for (i = 2; i < numEdges * 2; i += 2) {
	if (points[i] < minX) minX = points[i];
	if (points[i] > maxX) maxX = points[i];
	if (points[i + 1] < minY) minY = points[i + 1];
	if (points[i + 1] > maxY) maxY = points[i + 1];
    }


    // Fence fill algorithm
    for (y1 = minY; y1 <= maxY; y1++) {
	int isInside = 0;
	for (x1 = minX; x1 <= maxX; x1++) {
	    if (getpixel(x1, y1) == WHITE) {
		isInside = !isInside;
	    }
	    if (isInside) {
		putpixel(x1, y1, fillColor);
		delay(1);  // Add delay for visualization
	    }
	}
    }
}

int main() {
    int gd = DETECT, gm, i;
    int poly[] = {150, 150, 250, 150, 200, 200, 250, 250, 150, 250, 200, 200};
    int numEdges = sizeof(poly) / (2 * sizeof(int));

    initgraph(&gd, &gm, "C:\\Turboc3\\BGI");

    // Draw the polygon using Bresenham's line algorithm
    for (i = 0; i < (numEdges - 1) * 2; i += 2) {
        bresenhamLine(poly[i], poly[i + 1], poly[i + 2], poly[i + 3]);
    }
    // Close the polygon
    bresenhamLine(poly[(numEdges - 1) * 2], poly[(numEdges - 1) * 2 + 1], poly[0], poly[1]);

    // Fill the polygon using Fence Fill algorithm
    fenceFill(poly, numEdges, YELLOW);

    getch();
    closegraph();
    return 0;
}

------------------------------------------------------------------------------------------------------------------------------------------

10. Write a Program to implement Edge fill algorithm for a convex polygon. Draw polygon edges by DDA / Bresenham line algorithm.

#include <graphics.h>
#include <conio.h>

// Bresenham's line drawing algorithm
void bresenhamLine(int x1, int y1, int x2, int y2) {
      int dx = abs(x2 - x1);
int dy = abs(y2 - y1);
int sx = x1 < x2 ? 1 : -1;
int sy = y1 < y2 ? 1 : -1;
int err = dx - dy;
while (1) {
int e2;
putpixel(x1, y1, WHITE);
if (x1 == x2 && y1 == y2) break;
e2 = 2 * err;
if (e2 > -dy) { err -= dy; x1 += sx; }
if (e2 < dx) { err += dx; y1 += sy; }
}
}


// Edge Fill algorithm
void edgeFill(int *points, int numEdges, int fillColor) {
    int yMin = points[1], yMax = points[1],i,j,x,y;

    // Find the minimum and maximum y-coordinates
    for (i = 1; i < numEdges; i++) {
	if (points[2 * i + 1] < yMin)
	    yMin = points[2 * i + 1];
	if (points[2 * i + 1] > yMax)
	    yMax = points[2 * i + 1];
    }

    // Scan each horizontal line and fill the pixels between edges
    for (y = yMin; y <= yMax; y++) {
	int xIntersections[10];
	int numIntersections = 0;

	// Find intersections of scan line with edges
	for (i = 0; i < numEdges; i++) {
	    int x1 = points[2 * i], y1 = points[2 * i + 1];
	    int x2 = points[2 * ((i + 1) % numEdges)], y2 = points[2 * ((i + 1) % numEdges) + 1];

	    if ((y1 <= y && y < y2) || (y2 <= y && y < y1)) {
		// Calculate x-coordinate of intersection
		int xIntersection = x1 + (y - y1) * (x2 - x1) / (y2 - y1);
		xIntersections[numIntersections++] = xIntersection;
	    }
	}

	// Sort the intersection points
	for (i = 0; i < numIntersections - 1; i++) {
	    for (j = i + 1; j < numIntersections; j++) {
		if (xIntersections[i] > xIntersections[j]) {
		    int temp = xIntersections[i];
		    xIntersections[i] = xIntersections[j];
		    xIntersections[j] = temp;
		}
	    }
	}

	// Fill the horizontal gaps between intersections
	for (i = 0; i < numIntersections; i += 2) {
	    for (x = xIntersections[i]; x <= xIntersections[i + 1]; x++) {
                putpixel(x, y, fillColor);
            }
        }
    }
}

int main() {
    int gd = DETECT, gm,i;
int points[] = {150, 150, 250, 150, 225, 200, 200, 250, 175, 200};
    initgraph(&gd, &gm, "C:\\Turboc3\\BGI");

    // Vertices of the convex polygon
    

    // Draw the edges of the polygon
    for (i = 0; i < 8; i += 2) {
        bresenhamLine(points[i], points[i + 1], points[(i + 2) % 10], points[(i + 3) % 10]);
    }

    // Fill the polygon using the edge fill algorithm
    edgeFill(points, 5, YELLOW);

    getch();
    closegraph();
    return 0;
}

------------------------------------------------------------------------------------------------------------------------------------------

11. Write a Program to implement Scan line fill algorithm for a concave polygon. Draw polygon edges by DDA / Bresenham line algorithm.

#include <graphics.h>
#include <stdlib.h>
#include <stdio.h>

#define MAX_POINTS 20
#define INT_MAX  32767
#define INT_MIN  (-32768)


// Structure to represent a point (x, y)
struct Point {
    int x, y;
};

// Function to draw a line using Bresenham's algorithm
void drawLine(int x1, int y1, int x2, int y2) {
       int dx = abs(x2 - x1);
int dy = abs(y2 - y1);
int sx = x1 < x2 ? 1 : -1;
int sy = y1 < y2 ? 1 : -1;
int err = dx - dy;
while (1) {
int e2;
putpixel(x1, y1, WHITE);
if (x1 == x2 && y1 == y2) break;
e2 = 2 * err;
if (e2 > -dy) { err -= dy; x1 += sx; }
if (e2 < dx) { err += dx; y1 += sy; }
}
}

// Function to fill a polygon using the Scanline Fill algorithm
void scanlineFill(struct Point poly[], int n) {
    int i, y, ymin, ymax, x1, y1, x2, y2,j;

    // Find the minimum and maximum y-coordinates of the polygon
    ymin = poly[0].y;
    ymax = poly[0].y;
    for (i = 1; i < n; i++) {
	if (poly[i].y < ymin)
	    ymin = poly[i].y;
	if (poly[i].y > ymax)
	    ymax = poly[i].y;
    }

    // For each scanline from ymin to ymax
    for (y = ymin; y <= ymax; y++) {
	int intersections[MAX_POINTS];
	int count = 0;

	// Find intersections with the polygon edges
	for (i = 0; i < n; i++) {
	    int j = (i + 1) % n;
	    y1 = poly[i].y;
	    y2 = poly[j].y;
	    if ((y1 < y && y2 >= y) || (y2 < y && y1 >= y)) {
		x1 = poly[i].x;
		x2 = poly[j].x;
		intersections[count++] = x1 + (y - y1) * (x2 - x1) / (y2 - y1);
	    }
	}

	// Sort the intersections
	for (i = 0; i < count - 1; i++) {
	    for (j = 0; j < count - i - 1; j++) {
                if (intersections[j] > intersections[j + 1]) {
                    int temp = intersections[j];
                    intersections[j] = intersections[j + 1];
                    intersections[j + 1] = temp;
		}
            }
        }

        // Fill the scanline between pairs of intersections
        for (i = 0; i < count; i += 2) {
            drawLine(intersections[i], y, intersections[i + 1], y);
        }
    }
}

int main() {
    int gd = DETECT, gm,i;
    struct Point poly[] = {{100, 100}, {200, 100}, {250, 200}, {200, 300}, {100, 300}};
    int n = sizeof(poly) / sizeof(poly[0]);

    initgraph(&gd, &gm, "C:\\turboc3\\bgi");

    // Draw the polygon
    for (i = 0; i < n; i++) {
        int j = (i + 1) % n;
        drawLine(poly[i].x, poly[i].y, poly[j].x, poly[j].y);
    }

    // Fill the polygon
    scanlineFill(poly, n);

    delay(5000);
    closegraph();

    return 0;
}

------------------------------------------------------------------------------------------------------------------------------------------

12. Write a Program to implement 2D Scaling and rotation of a triangle.

#include <stdio.h>
#include <conio.h>
#include <graphics.h>
#include <math.h>

void drawTriangle(int x1, int y1, int x2, int y2, int x3, int y3) {
    line(x1, y1, x2, y2);
    line(x2, y2, x3, y3);
    line(x3, y3, x1, y1);
}

void scaleTriangle(int *x1, int *y1, int *x2, int *y2, int *x3, int *y3, float scaleX, float scaleY) {
    *x1 *= scaleX;
    *y1 *= scaleY;
    *x2 *= scaleX;
    *y2 *= scaleY;
    *x3 *= scaleX;
    *y3 *= scaleY;
}

void rotatePoint(int *x, int *y, float angle) {
    float radians = angle * (3.14159 / 180);
    float newX = *x * cos(radians) - *y * sin(radians);
    float newY = *x * sin(radians) + *y * cos(radians);
    *x = (int)newX;
    *y = (int)newY;
}

void rotateTriangle(int *x1, int *y1, int *x2, int *y2, int *x3, int *y3, float angle) {
    int centroidX = (*x1 + *x2 + *x3) / 3;
    int centroidY = (*y1 + *y2 + *y3) / 3;

    *x1 -= centroidX;
    *y1 -= centroidY;
    *x2 -= centroidX;
    *y2 -= centroidY;
    *x3 -= centroidX;
    *y3 -= centroidY;

    rotatePoint(x1, y1, angle);
    rotatePoint(x2, y2, angle);
    rotatePoint(x3, y3, angle);

    *x1 += centroidX;
    *y1 += centroidY;
    *x2 += centroidX;
    *y2 += centroidY;
    *x3 += centroidX;
    *y3 += centroidY;
}

int main() {
    int x1, y1, x2, y2, x3, y3;
    float scaleX, scaleY;
    float angle;
    int gd = DETECT, gm;
    initgraph(&gd, &gm, "C:\\TURBOC3\\BGI");

    printf("Enter coordinates of triangle (x1 y1 x2 y2 x3 y3): ");
    scanf("%d %d %d %d %d %d", &x1, &y1, &x2, &y2, &x3, &y3);

    drawTriangle(x1, y1, x2, y2, x3, y3);
    getch();
    cleardevice();

    printf("Enter scaling factors (scaleX scaleY): ");
    scanf("%f %f", &scaleX, &scaleY);
    scaleTriangle(&x1, &y1, &x2, &y2, &x3, &y3, scaleX, scaleY);

    drawTriangle(x1, y1, x2, y2, x3, y3);
    getch();
    cleardevice();

    printf("Enter rotation angle in degrees: ");
    scanf("%f", &angle);
    rotateTriangle(&x1, &y1, &x2, &y2, &x3, &y3, angle);

    drawTriangle(x1, y1, x2, y2, x3, y3);
    getch();

    closegraph();
    return 0;
}

//100 100 200 100 150 200
//1.5 0.8
//45

------------------------------------------------------------------------------------------------------------------------------------------

13. Write a Program to implement 2D Scaling and translation of a triangle.

#include <graphics.h>
#include <stdlib.h>
#include <stdio.h>
#include <conio.h>

void drawTriangle(int x1, int y1, int x2, int y2, int x3, int y3) {
    line(x1, y1, x2, y2);
    line(x2, y2, x3, y3);
    line(x3, y3, x1, y1);
}

void scaleTriangle(int x1, int y1, int x2, int y2, int x3, int y3, float scaleX, float scaleY) {
    x1 *= scaleX;
    y1 *= scaleY;
    x2 *= scaleX;
    y2 *= scaleY;
    x3 *= scaleX;
    y3 *= scaleY;

    drawTriangle(x1, y1, x2, y2, x3, y3);
}

void translateTriangle(int x1, int y1, int x2, int y2, int x3, int y3, int tx, int ty) {
    x1 += tx;
    y1 += ty;
    x2 += tx;
    y2 += ty;
    x3 += tx;
    y3 += ty;

    drawTriangle(x1, y1, x2, y2, x3, y3);
}

int main() {
    int x1, y1, x2, y2, x3, y3, tx, ty;
    float scaleX, scaleY;
    int gd = DETECT, gm;
    initgraph(&gd, &gm, "C:\\TURBOC3\\BGI");

    

    // Clear screen
    cleardevice();

    // Get user input for triangle coordinates
    printf("Enter coordinates of triangle (x1 y1 x2 y2 x3 y3): ");
    scanf("%d %d %d %d %d %d", &x1, &y1, &x2, &y2, &x3, &y3);

    // Draw original triangle
    drawTriangle(x1, y1, x2, y2, x3, y3);
    getch();
    cleardevice();

    // Get user input for scaling factor
    printf("Enter scaling factors (scaleX scaleY): ");
    scanf("%f %f", &scaleX, &scaleY);

    // Draw scaled triangle
    scaleTriangle(x1, y1, x2, y2, x3, y3, scaleX, scaleY);
    getch();
    cleardevice();

    // Get user input for translation values
    printf("Enter translation values (tx ty): ");
    scanf("%d %d", &tx, &ty);

    // Draw translated triangle
    translateTriangle(x1, y1, x2, y2, x3, y3, tx, ty);
    getch();
    cleardevice();

    closegraph();
    return 0;
}

//100 100 200 200 150 50
//1.5 1.5
//50 50

------------------------------------------------------------------------------------------------------------------------------------------

14. Write a Program to implement 2D rotation and translation of a triangle.

#include <graphics.h>
#include <stdlib.h>
#include <stdio.h>
#include <conio.h>
#include <math.h>

#define PI 3.14159265

void drawTriangle(int x1, int y1, int x2, int y2, int x3, int y3) {
    line(x1, y1, x2, y2);
    line(x2, y2, x3, y3);
    line(x3, y3, x1, y1);
}

void rotateTriangle(int x1, int y1, int x2, int y2, int x3, int y3, float angle) {
    float rad = angle * PI / 180.0; // Convert angle to radians
    float cosTheta = cos(rad);
    float sinTheta = sin(rad);

    int x1New = x1 * cosTheta - y1 * sinTheta;
    int y1New = x1 * sinTheta + y1 * cosTheta;
    int x2New = x2 * cosTheta - y2 * sinTheta;
    int y2New = x2 * sinTheta + y2 * cosTheta;
    int x3New = x3 * cosTheta - y3 * sinTheta;
    int y3New = x3 * sinTheta + y3 * cosTheta;

    drawTriangle(x1New, y1New, x2New, y2New, x3New, y3New);
}

void translateTriangle(int x1, int y1, int x2, int y2, int x3, int y3, int tx, int ty) {
    x1 += tx;
    y1 += ty;
    x2 += tx;
    y2 += ty;
    x3 += tx;
    y3 += ty;

    drawTriangle(x1, y1, x2, y2, x3, y3);
}

int main() {
    int x1, y1, x2, y2, x3, y3;
    float angle;
    int tx, ty;
    int gd = DETECT, gm;
    initgraph(&gd, &gm, "C:\\TURBOC3\\BGI");

    // Get user input for triangle coordinates
    printf("Enter coordinates of triangle (x1 y1 x2 y2 x3 y3): ");
    scanf("%d %d %d %d %d %d", &x1, &y1, &x2, &y2, &x3, &y3);

    // Clear screen
    cleardevice();

    // Draw original triangle
    drawTriangle(x1, y1, x2, y2, x3, y3);
    getch();
    cleardevice();

    // Get user input for rotation angle
    printf("Enter rotation angle (in degrees): ");
    scanf("%f", &angle);

    // Draw rotated triangle
    rotateTriangle(x1, y1, x2, y2, x3, y3, angle);
    getch();
    cleardevice();

    // Get user input for translation values
    printf("Enter translation values (tx ty): ");
    scanf("%d %d", &tx, &ty);

    // Draw translated triangle
    translateTriangle(x1, y1, x2, y2, x3, y3, tx, ty);
    getch();
    cleardevice();

    closegraph();
    return 0;
}
//100 100 200 100 150 50
//45
//50 50

------------------------------------------------------------------------------------------------------------------------------------------

15. Write a C program to show that R(θ1) . R(θ2) = R(θ1 + θ2)

#include <graphics.h>
#include <stdlib.h>
#include <stdio.h>
#include <conio.h>
#include <math.h>

#define PI 3.14159265

void drawTriangle(int x1, int y1, int x2, int y2, int x3, int y3) {
    line(x1, y1, x2, y2);
    line(x2, y2, x3, y3);
    line(x3, y3, x1, y1);
}

void rotateTriangle(int x1, int y1, int x2, int y2, int x3, int y3, float angle) {
    float rad = angle * PI / 180.0; // Convert angle to radians
    float cosTheta = cos(rad);
    float sinTheta = sin(rad);

    int x1New = (int)(x1 * cosTheta - y1 * sinTheta);
    int y1New = (int)(x1 * sinTheta + y1 * cosTheta);
    int x2New = (int)(x2 * cosTheta - y2 * sinTheta);
    int y2New = (int)(x2 * sinTheta + y2 * cosTheta);
    int x3New = (int)(x3 * cosTheta - y3 * sinTheta);
    int y3New = (int)(x3 * sinTheta + y3 * cosTheta);

    drawTriangle(x1New, y1New, x2New, y2New, x3New, y3New);
}

int main() {
    int x1, y1, x2, y2, x3, y3;
    float angle1, angle2;
    float combinedAngle = angle1 + angle2;
    int gd = DETECT, gm;
    initgraph(&gd, &gm, "C:\\TURBOC3\\BGI");



    // Get user input for triangle coordinates
    printf("Enter coordinates of triangle (x1 y1 x2 y2 x3 y3): ");
    scanf("%d %d %d %d %d %d", &x1, &y1, &x2, &y2, &x3, &y3);

    // Get user input for rotation angles
    printf("Enter rotation angle 1 (in degrees): ");
    scanf("%f", &angle1);
    printf("Enter rotation angle 2 (in degrees): ");
    scanf("%f", &angle2);

    // Clear screen
    cleardevice();

    // Draw original triangle
    printf("Original Figure:");
    drawTriangle(x1, y1, x2, y2, x3, y3);
    getch();
    cleardevice();

    // Draw first rotation
    printf("First Rotation:");
    rotateTriangle(x1, y1, x2, y2, x3, y3, angle1);
    getch();
    cleardevice();

    // Draw second rotation
    printf("Second Rotation:");
    rotateTriangle(x1, y1, x2, y2, x3, y3, angle2);
    getch();
    cleardevice();

    // Calculate and draw combined rotation
    printf("Combined R(01 + 02):");
    rotateTriangle(x1, y1, x2, y2, x3, y3, combinedAngle);
    getch();
    cleardevice();

    closegraph();
    return 0;
}

//100 100 200 100 150 50
//30
//45

------------------------------------------------------------------------------------------------------------------------------------------

16. Write a C program to show that R(θ1) . R(θ2) = R(θ2) . R(θ1)



17. Write a C program to show that two successive translations are additive in nature.

#include <graphics.h>
#include <stdlib.h>
#include <stdio.h>
#include <conio.h>

void drawTriangle(int x1, int y1, int x2, int y2, int x3, int y3) {
    line(x1, y1, x2, y2);
    line(x2, y2, x3, y3);
    line(x3, y3, x1, y1);
}

void translateTriangle(int x1, int y1, int x2, int y2, int x3, int y3, int tx, int ty) {
    drawTriangle(x1 + tx, y1 + ty, x2 + tx, y2 + ty, x3 + tx, y3 + ty);
}

int main() {
    int x1, y1, x2, y2, x3, y3;
    int tx1, ty1, tx2, ty2;
    int gd = DETECT, gm;
    initgraph(&gd, &gm, "C:\\TURBOC3\\BGI");

    // Get user input for triangle coordinates
    printf("Enter coordinates of triangle (x1 y1 x2 y2 x3 y3): ");
    scanf("%d %d %d %d %d %d", &x1, &y1, &x2, &y2, &x3, &y3);

    // Get user input for translation amounts
    printf("Enter translation amount for the first translation (tx1 ty1): ");
    scanf("%d %d", &tx1, &ty1);
    printf("Enter translation amount for the second translation (tx2 ty2): ");
    scanf("%d %d", &tx2, &ty2);

    // Clear screen
    cleardevice();

    // Draw original triangle
    printf("Original Figure:");
    drawTriangle(x1, y1, x2, y2, x3, y3);
    getch();
    cleardevice();

    // First translation
    printf("First Translation:");
    translateTriangle(x1, y1, x2, y2, x3, y3, tx1, ty1);
    getch();
    cleardevice();

    // Second translation
    printf("Second Translation:");
    translateTriangle(x1, y1, x2, y2, x3, y3, tx2, ty2);
    getch();
    cleardevice();

    // Combined translation
    printf("Additive Translation:");
    translateTriangle(x1, y1, x2, y2, x3, y3, tx1 + tx2, ty1 + ty2);
    getch();
    cleardevice();

    closegraph();
    return 0;
}
//100 100 200 100 150 50
//30 50
//20 40

------------------------------------------------------------------------------------------------------------------------------------------

18. Write a C program to show that two successive rotations are commutative in nature.

#include <graphics.h>
#include <stdlib.h>
#include <stdio.h>
#include <conio.h>
#include <math.h>

#define PI 3.14159265

void drawTriangle(int x1, int y1, int x2, int y2, int x3, int y3) {
    line(x1, y1, x2, y2);
    line(x2, y2, x3, y3);
    line(x3, y3, x1, y1);
}

void rotatePoint(int *x, int *y, float angle) {
    float rad = angle * PI / 180.0; // Convert angle to radians
    float cosTheta = cos(rad);
    float sinTheta = sin(rad);

    int xNew = (*x) * cosTheta - (*y) * sinTheta;
    int yNew = (*x) * sinTheta + (*y) * cosTheta;

    *x = xNew;
    *y = yNew;
}

int main() {
    int x1, y1, x2, y2, x3, y3;
    float angle1, angle2;
    int gd = DETECT, gm;
    initgraph(&gd, &gm, "C:\\TURBOC3\\BGI");

    // Get user input for triangle coordinates
    printf("Enter coordinates of triangle (x1 y1 x2 y2 x3 y3): ");
    scanf("%d %d %d %d %d %d", &x1, &y1, &x2, &y2, &x3, &y3);

    // Get user input for rotation angles
    printf("Enter rotation angle 1 (in degrees): ");
    scanf("%f", &angle1);
    printf("Enter rotation angle 2 (in degrees): ");
    scanf("%f", &angle2);

    // Clear screen
    cleardevice();

    // Draw original triangle
    printf("Original Figure:");
    drawTriangle(x1, y1, x2, y2, x3, y3);
    getch();
    cleardevice();

    // First rotation
    printf("First Rotation:");
    rotatePoint(&x1, &y1, angle1);
    rotatePoint(&x2, &y2, angle1);
    rotatePoint(&x3, &y3, angle1);
    drawTriangle(x1, y1, x2, y2, x3, y3);
    getch();
    cleardevice();

    // Second rotation
    printf("Second Rotation:");
    x1 = x1 - x2;
    y1 = y1 - y2;
    x3 = x3 - x2;
    y3 = y3 - y2;
    rotatePoint(&x1, &y1, angle2);
    rotatePoint(&x3, &y3, angle2);
    x1 = x1 + x2;
    y1 = y1 + y2;
    x3 = x3 + x2;
    y3 = y3 + y2;
    drawTriangle(x1, y1, x2, y2, x3, y3);
    getch();
    cleardevice();

    // Reset triangle to original position
    printf("Original Figure:");
    drawTriangle(x1, y1, x2, y2, x3, y3);

    // Combined rotation: Rotate by angle2 first, then angle1
    printf("From angle2 then angle1:");
    x1 = x1 - x2;
    y1 = y1 - y2;
    x3 = x3 - x2;
    y3 = y3 - y2;
    rotatePoint(&x1, &y1, angle2);
    rotatePoint(&x3, &y3, angle2);
    x1 = x1 + x2;
    y1 = y1 + y2;
    x3 = x3 + x2;
    y3 = y3 + y2;
    x1 = x1 - x2;
    y1 = y1 - y2;
    x3 = x3 - x2;
    y3 = y3 - y2;
    rotatePoint(&x1, &y1, angle1);
    rotatePoint(&x3, &y3, angle1);
    x1 = x1 + x2;
    y1 = y1 + y2;
    x3 = x3 + x2;
    y3 = y3 + y2;
    drawTriangle(x1, y1, x2, y2, x3, y3);
    getch();
    cleardevice();

    // Reset triangle to original position
    printf("Original Figure:");
    drawTriangle(x1, y1, x2, y2, x3, y3);

    // Combined rotation: Rotate by angle1 first, then angle2
    printf("From angle1 then angle2:");
    x1 = x1 - x2;
    y1 = y1 - y2;
    x3 = x3 - x2;
    y3 = y3 - y2;
    rotatePoint(&x1, &y1, angle1);
    rotatePoint(&x3, &y3, angle1);
    x1 = x1 + x2;
    y1 = y1 + y2;
    x3 = x3 + x2;
    y3 = y3 + y2;
    x1 = x1 - x2;
    y1 = y1 - y2;
    x3 = x3 - x2;
    y3 = y3 - y2;
    rotatePoint(&x1, &y1, angle2);
    rotatePoint(&x3, &y3, angle2);
    x1 = x1 + x2;
    y1 = y1 + y2;
    x3 = x3 + x2;
    y3 = y3 + y2;
    drawTriangle(x1, y1, x2, y2, x3, y3);
    getch();
    cleardevice();

    closegraph();
    return 0;
}
//100 100 200 100 150 50
//30
//60

------------------------------------------------------------------------------------------------------------------------------------------

19. Write a C program to show that two successive translations are commutative in nature.

#include <graphics.h>
#include <stdlib.h>
#include <stdio.h>
#include <conio.h>

void drawTriangle(int x1, int y1, int x2, int y2, int x3, int y3) {
    line(x1, y1, x2, y2);
    line(x2, y2, x3, y3);
    line(x3, y3, x1, y1);
}

void translateTriangle(int *x1, int *y1, int *x2, int *y2, int *x3, int *y3, int dx, int dy) {
    *x1 += dx;
    *y1 += dy;
    *x2 += dx;
    *y2 += dy;
    *x3 += dx;
    *y3 += dy;
}

int main() {
    int x1, y1, x2, y2, x3, y3;
    int dx1, dy1, dx2, dy2; // Translation amounts
    int gd = DETECT, gm;
    initgraph(&gd, &gm, "C:\\TURBOC3\\BGI");

    // Get user input for triangle coordinates
    printf("Enter coordinates of triangle (x1 y1 x2 y2 x3 y3): ");
    scanf("%d %d %d %d %d %d", &x1, &y1, &x2, &y2, &x3, &y3);

    // Get user input for translation amounts
    printf("Enter translation amount for the first translation (dx1 dy1): ");
    scanf("%d %d", &dx1, &dy1);
    printf("Enter translation amount for the second translation (dx2 dy2): ");
    scanf("%d %d", &dx2, &dy2);

    // Clear screen
    cleardevice();

    // Draw original triangle
    printf("Original Figure:");
    drawTriangle(x1, y1, x2, y2, x3, y3);
    getch();
    cleardevice();

    // First translation
    printf("First Translation:");
    translateTriangle(&x1, &y1, &x2, &y2, &x3, &y3, dx1, dy1);
    drawTriangle(x1, y1, x2, y2, x3, y3);
    getch();
    cleardevice();

    // Second translation
    printf("Second Translation:");
    translateTriangle(&x1, &y1, &x2, &y2, &x3, &y3, dx2, dy2);
    drawTriangle(x1, y1, x2, y2, x3, y3);
    getch();
    cleardevice();

    // Reset triangle to original position
    x1 -= dx2;
    y1 -= dy2;
    x2 -= dx2;
    y2 -= dy2;
    x3 -= dx2;
    y3 -= dy2;

    // Combined translation: Translate by dx2 first, then dx1
    printf("Translation from dx2 then dx1:");
    translateTriangle(&x1, &y1, &x2, &y2, &x3, &y3, dx2, dy2);
    translateTriangle(&x1, &y1, &x2, &y2, &x3, &y3, dx1, dy1);
    drawTriangle(x1, y1, x2, y2, x3, y3);
    getch();
    cleardevice();

    // Reset triangle to original position
    x1 += dx2;
    y1 += dy2;
    x2 += dx2;
    y2 += dy2;
    x3 += dx2;
    y3 += dy2;

    // Combined translation: Translate by dx1 first, then dx2
     printf("Translation from dx1 then dx2:");
    translateTriangle(&x1, &y1, &x2, &y2, &x3, &y3, dx1, dy1);
    translateTriangle(&x1, &y1, &x2, &y2, &x3, &y3, dx2, dy2);
    drawTriangle(x1, y1, x2, y2, x3, y3);
    getch();
    cleardevice();

    closegraph();
    return 0;
}
//100 100 200 100 150 50
//30 50
//20 40

------------------------------------------------------------------------------------------------------------------------------------------

20. Write a C Program to show that Reflection about a line Y=X is equivalent to reflection relative to X-axis followed by anticlockwise rotation of 900.

#include <graphics.h>
#include <stdio.h>
#include <conio.h>

void drawTriangle(int x1, int y1, int x2, int y2, int x3, int y3) {
    line(x1, y1, x2, y2);
    line(x2, y2, x3, y3);
    line(x3, y3, x1, y1);
}

void reflectAboutYEqualsX(int *x, int *y) {
    int temp = *x;
    *x = *y;
    *y = temp;
}

void reflectAboutXAxis(int *x, int *y) {
    *y = 2 * 200 - *y; // Reflect about x-axis
}

void rotate90AntiClockwise(int *x, int *y) {
    int temp = *x;
    *x = *y;
    *y = 2 * 200 - temp; // Rotate 90 degrees anticlockwise
}

void reflectTriangle(int *x1, int *y1, int *x2, int *y2, int *x3, int *y3) {
    reflectAboutYEqualsX(x1, y1);
    reflectAboutYEqualsX(x2, y2);
    reflectAboutYEqualsX(x3, y3);
}

int main() {
    int x1, y1, x2, y2, x3, y3;
    int gd = DETECT, gm;
    initgraph(&gd, &gm, "C:\\TURBOC3\\BGI");

    // Get user input for triangle coordinates
    printf("Enter coordinates of triangle (x1 y1 x2 y2 x3 y3): ");
    scanf("%d %d %d %d %d %d", &x1, &y1, &x2, &y2, &x3, &y3);

    // Clear screen
    cleardevice();

    // Draw original triangle
    printf("Original Figure:");
    drawTriangle(x1, y1, x2, y2, x3, y3);
    getch();
    cleardevice();

    // Reflect about y=x
    printf("Reflection about y=x:");
    reflectTriangle(&x1, &y1, &x2, &y2, &x3, &y3);
    drawTriangle(x1, y1, x2, y2, x3, y3);
    getch();
    cleardevice();

    // Reset triangle to original position
   // reflectTriangle(&x1, &y1, &x2, &y2, &x3, &y3);

    // Reflect about x-axis
    reflectAboutXAxis(&x1, &y1);
    reflectAboutXAxis(&x2, &y2);
    reflectAboutXAxis(&x3, &y3);
    printf("Reflection about x-axis:");
    drawTriangle(x1, y1, x2, y2, x3, y3);
    getch();
    cleardevice();

    // Reset triangle to original position
   // reflectAboutXAxis(&x1, &y1);
   // reflectAboutXAxis(&x2, &y2);
   // reflectAboutXAxis(&x3, &y3);

    // Rotate 90 degrees anticlockwise
    printf("Rotation 90 degrees anticlockwise:");
    rotate90AntiClockwise(&x1, &y1);
    rotate90AntiClockwise(&x2, &y2);
    rotate90AntiClockwise(&x3, &y3);
    drawTriangle(x1, y1, x2, y2, x3, y3);
    getch();
    cleardevice();

    closegraph();
    return 0;
}

//50 100 150 100 100 200

------------------------------------------------------------------------------------------------------------------------------------------

21. Write a Program to implement all type of reflections about X axis and about Y axis of a triangle.

#include <graphics.h>
#include <stdlib.h>
#include <stdio.h>
#include <conio.h>

// Function to draw a triangle
void drawTriangle(int x1, int y1, int x2, int y2, int x3, int y3) {
    line(x1, y1, x2, y2);
    line(x2, y2, x3, y3);
    line(x3, y3, x1, y1);
}

// Function to reflect the triangle about the X-axis
void reflectAboutXAxis(int *x1, int *y1, int *x2, int *y2, int *x3, int *y3) {
    *y1 = 2 * 200 - *y1;
    *y2 = 2 * 200 - *y2;
    *y3 = 2 * 200 - *y3;
}

// Function to reflect the triangle about the Y-axis
void reflectAboutYAxis(int *x1, int *y1, int *x2, int *y2, int *x3, int *y3) {
    *x1 = 2 * 200 - *x1;
    *x2 = 2 * 200 - *x2;
    *x3 = 2 * 200 - *x3;
}

int main() {
    int x1, y1, x2, y2, x3, y3;
    int gd = DETECT, gm;
    initgraph(&gd, &gm, "C:\\TURBOC3\\BGI");

    // Get user input for triangle coordinates
    printf("Enter coordinates of triangle (x1 y1 x2 y2 x3 y3): ");
    scanf("%d %d %d %d %d %d", &x1, &y1, &x2, &y2, &x3, &y3);

    // Draw original triangle
    printf("Original Figure:");
    drawTriangle(x1, y1, x2, y2, x3, y3);
    getch();
    cleardevice();

    // Reflect about X-axis
    printf("Reflection About x-axis:");
    reflectAboutXAxis(&x1, &y1, &x2, &y2, &x3, &y3);
    drawTriangle(x1, y1, x2, y2, x3, y3);
    getch();
    cleardevice();

    // Reset triangle to original position
    reflectAboutXAxis(&x1, &y1, &x2, &y2, &x3, &y3);

    // Reflect about Y-axis
    printf("Reflection About y-axis:");
    reflectAboutYAxis(&x1, &y1, &x2, &y2, &x3, &y3);
    drawTriangle(x1, y1, x2, y2, x3, y3);
    getch();
    cleardevice();

    closegraph();
    return 0;
}

//50 100 150 100 100 200

------------------------------------------------------------------------------------------------------------------------------------------

22. Write a Program to implement all type of reflections about origin and about a line Y = X for a triangle.

#include <graphics.h>
#include <stdlib.h>
#include <stdio.h>
#include <conio.h>

// Function to draw a triangle
void drawTriangle(int x1, int y1, int x2, int y2, int x3, int y3) {
    line(x1, y1, x2, y2);
    line(x2, y2, x3, y3);
    line(x3, y3, x1, y1);
}

// Function to reflect the triangle about the origin
void reflectAboutOrigin(int *x1, int *y1, int *x2, int *y2, int *x3, int *y3) {
    *x1 = 2 * 200 - *x1;
    *y1 = 2 * 200 - *y1;
    *x2 = 2 * 200 - *x2;
    *y2 = 2 * 200 - *y2;
    *x3 = 2 * 200 - *x3;
    *y3 = 2 * 200 - *y3;
}

// Function to reflect the triangle about the line y = x
void reflectAboutYEqualsX(int *x, int *y) {
    int temp = *x;
    *x = *y;
    *y = temp;
}

int main() {
    int x1, y1, x2, y2, x3, y3;
    int gd = DETECT, gm;
    initgraph(&gd, &gm, "C:\\TURBOC3\\BGI");

    // Get user input for triangle coordinates
    printf("Enter coordinates of triangle (x1 y1 x2 y2 x3 y3): ");
    scanf("%d %d %d %d %d %d", &x1, &y1, &x2, &y2, &x3, &y3);

    // Draw original triangle
    printf("Original Figure:");
    drawTriangle(x1, y1, x2, y2, x3, y3);
    getch();
    cleardevice();

    // Reflect about origin
    printf("Reflection about origin:");
    reflectAboutOrigin(&x1, &y1, &x2, &y2, &x3, &y3);
    drawTriangle(x1, y1, x2, y2, x3, y3);
    getch();
    cleardevice();

    // Reset triangle to original position
    reflectAboutOrigin(&x1, &y1, &x2, &y2, &x3, &y3);

    // Reflect about the line y = x
    printf("Reflection about the line y=x:");
    reflectAboutYEqualsX(&x1, &y1);
    reflectAboutYEqualsX(&x2, &y2);
    reflectAboutYEqualsX(&x3, &y3);
    drawTriangle(x1, y1, x2, y2, x3, y3);
    getch();
    cleardevice();

    closegraph();
    return 0;
}
//50 100 150 100 100 200

------------------------------------------------------------------------------------------------------------------------------------------

23. Write a Program to implement X and Y shear transformation

#include <graphics.h>
#include <stdlib.h>
#include <stdio.h>
#include <conio.h>

// Function to draw a triangle
void drawTriangle(int x1, int y1, int x2, int y2, int x3, int y3) {
    line(x1, y1, x2, y2);
    line(x2, y2, x3, y3);
    line(x3, y3, x1, y1);
}

// Function to perform X shear transformation
void shearX(int *x, int y, float shear_factor) {
    *x += shear_factor * y;
}

// Function to perform Y shear transformation
void shearY(int x, int *y, float shear_factor) {
    *y += shear_factor * x;
}

int main() {
    int x1, y1, x2, y2, x3, y3;
    float shear_factor_x;
    float shear_factor_y;
    int gd = DETECT, gm;
    initgraph(&gd, &gm, "C:\\TURBOC3\\BGI");



    // Get user input for triangle coordinates
    printf("Enter coordinates of triangle (x1 y1 x2 y2 x3 y3): ");
    scanf("%d %d %d %d %d %d", &x1, &y1, &x2, &y2, &x3, &y3);

    // Draw original triangle
    drawTriangle(x1, y1, x2, y2, x3, y3);
    getch();
    cleardevice();

    // Perform X shear transformation

    printf("Enter X shear factor: ");
    scanf("%f", &shear_factor_x);
    shearX(&x1, y1, shear_factor_x);
    shearX(&x2, y2, shear_factor_x);
    shearX(&x3, y3, shear_factor_x);
    drawTriangle(x1, y1, x2, y2, x3, y3);
    getch();
    cleardevice();

    // Reset triangle to original position
    printf("Resetting triangle to original position...\n");
    x1 = x1 - shear_factor_x * y1;
    x2 = x2 - shear_factor_x * y2;
    x3 = x3 - shear_factor_x * y3;

    // Perform Y shear transformation

    printf("Enter Y shear factor: ");
    scanf("%f", &shear_factor_y);
    shearY(x1, &y1, shear_factor_y);
    shearY(x2, &y2, shear_factor_y);
    shearY(x3, &y3, shear_factor_y);
    drawTriangle(x1, y1, x2, y2, x3, y3);
    getch();

    closegraph();
    return 0;
}
//100 100 200 100 150 200
//1.0
//1.0

------------------------------------------------------------------------------------------------------------------------------------------

24. Write a Program to implement rotation about arbitrary point.

#include <graphics.h>
#include <stdlib.h>
#include <stdio.h>
#include <conio.h>
#include <math.h>

// Function to draw a point
void drawPoint(int x, int y) {
    putpixel(x, y, WHITE);
}

// Function to draw a triangle
void drawTriangle(int x1, int y1, int x2, int y2, int x3, int y3) {
    line(x1, y1, x2, y2);
    line(x2, y2, x3, y3);
    line(x3, y3, x1, y1);
}

// Function to rotate a point about another point
void rotatePoint(int *x, int *y, int pivotX, int pivotY, float angle) {
    float rad = angle * (3.14159 / 180.0);
    int newX = pivotX + (*x - pivotX) * cos(rad) - (*y - pivotY) * sin(rad);
    int newY = pivotY + (*x - pivotX) * sin(rad) + (*y - pivotY) * cos(rad);
    *x = newX;
    *y = newY;
}

// Function to rotate a triangle about an arbitrary point
void rotateTriangle(int *x1, int *y1, int *x2, int *y2, int *x3, int *y3, int pivotX, int pivotY, float angle) {
    rotatePoint(x1, y1, pivotX, pivotY, angle);
    rotatePoint(x2, y2, pivotX, pivotY, angle);
    rotatePoint(x3, y3, pivotX, pivotY, angle);
}

int main() {
    int x1, y1, x2, y2, x3, y3;
    int pivotX, pivotY;
    float angle;
    int gd = DETECT, gm;
    initgraph(&gd, &gm, "C:\\TURBOC3\\BGI");

    // Get user input for triangle coordinates
    printf("Enter coordinates of triangle (x1 y1 x2 y2 x3 y3): ");
    scanf("%d %d %d %d %d %d", &x1, &y1, &x2, &y2, &x3, &y3);

    // Get user input for pivot point
    printf("Enter pivot point coordinates (pivotX pivotY): ");
    scanf("%d %d", &pivotX, &pivotY);

    // Get user input for rotation angle
    printf("Enter rotation angle in degrees: ");
    scanf("%f", &angle);

    // Draw original triangle and pivot point
    drawTriangle(x1, y1, x2, y2, x3, y3);
    drawPoint(pivotX, pivotY);
    getch();
    cleardevice();

    // Rotate triangle about arbitrary pivot point
    rotateTriangle(&x1, &y1, &x2, &y2, &x3, &y3, pivotX, pivotY, angle);

    // Draw rotated triangle and pivot point
    printf("Rotation about Arbitrary Point:");
    drawTriangle(x1, y1, x2, y2, x3, y3);
    drawPoint(pivotX, pivotY);
    getch();

    closegraph();
    return 0;
}
//100 100 200 100 150 200
//200 200
//45

------------------------------------------------------------------------------------------------------------------------------------------

25. Write a Program to implement Cohen Sutherland line clipping algorithm.

#include <graphics.h>
#include <stdio.h>
#include <conio.h>

// Define region codes for the four regions
#define INSIDE 0 // 0000
#define LEFT 1   // 0001
#define RIGHT 2  // 0010
#define BOTTOM 4 // 0100
#define TOP 8    // 1000

// Define the clipping window coordinates
#define X_MIN 100
#define Y_MIN 100
#define X_MAX 300
#define Y_MAX 300

// Function to compute the region code for a point
int computeRegionCode(int x, int y) {
    int code = INSIDE;
    if (x < X_MIN) // to the left of clip window
        code |= LEFT;
    else if (x > X_MAX) // to the right of clip window
        code |= RIGHT;
    if (y < Y_MIN) // below the clip window
        code |= BOTTOM;
    else if (y > Y_MAX) // above the clip window
        code |= TOP;
    return code;
}

// Function to clip a line segment
void cohenSutherland(int x1, int y1, int x2, int y2) {
    int code1 = computeRegionCode(x1, y1);
    int code2 = computeRegionCode(x2, y2);
    int accept = 0;

    while (1) {
        if (!(code1 | code2)) { // Both endpoints are inside the window
            accept = 1;
            break;
        } else if (code1 & code2) { // Both endpoints are outside the window
            break;
        } else {
            // Partially inside, partially outside
            int x, y;
            int codeOut = code1 ? code1 : code2;
            // Find the intersection point
            if (codeOut & TOP) { // point is above the clip rectangle
                x = x1 + (x2 - x1) * (Y_MAX - y1) / (y2 - y1);
                y = Y_MAX;
            } else if (codeOut & BOTTOM) { // point is below the clip rectangle
                x = x1 + (x2 - x1) * (Y_MIN - y1) / (y2 - y1);
                y = Y_MIN;
            } else if (codeOut & RIGHT) { // point is to the right of the clip rectangle
                y = y1 + (y2 - y1) * (X_MAX - x1) / (x2 - x1);
                x = X_MAX;
            } else if (codeOut & LEFT) { // point is to the left of the clip rectangle
                y = y1 + (y2 - y1) * (X_MIN - x1) / (x2 - x1);
                x = X_MIN;
            }

            // Replace the outside point with intersection point
            if (codeOut == code1) {
                x1 = x;
                y1 = y;
                code1 = computeRegionCode(x1, y1);
            } else {
                x2 = x;
                y2 = y;
                code2 = computeRegionCode(x2, y2);
            }
        }
    }

    // If the line segment is accepted, draw it
    if (accept) {
        setcolor(WHITE);
        line(x1, y1, x2, y2);
    }
}

int main() {
    int x1, y1, x2, y2;
    int gd = DETECT, gm;
    initgraph(&gd, &gm, "C:\\TURBOC3\\BGI");

    // Draw clipping window
    rectangle(X_MIN, Y_MIN, X_MAX, Y_MAX);

    // Draw line segment
    
    printf("Enter coordinates of line (x1 y1 x2 y2): ");
    scanf("%d %d %d %d", &x1, &y1, &x2, &y2);
    setcolor(BLUE);
    line(x1, y1, x2, y2);

    // Clip the line segment
    cohenSutherland(x1, y1, x2, y2);

    getch();
    cleardevice();

    // Draw clipping window again
    printf("Clipped Figure:");
    rectangle(X_MIN, Y_MIN, X_MAX, Y_MAX);
    cohenSutherland(x1, y1, x2, y2);

    getch();
    closegraph();
    return 0;
}
//50 150 250 350

------------------------------------------------------------------------------------------------------------------------------------------

26. Write a Program to implement midpoint line clipping algorithm.

#include <graphics.h>
#include <stdio.h>
#include <conio.h>

#define INSIDE 0 // Inside of the clip window
#define LEFT 1   // Left side of the clip window
#define RIGHT 2  // Right side of the clip window
#define BOTTOM 4 // Below the clip window
#define TOP 8    // Above the clip window

#define X_MIN 100
#define Y_MIN 100
#define X_MAX 300
#define Y_MAX 300

// Function to determine the region code for a point
int computeRegionCode(int x, int y) {
    int code = INSIDE;
    if (x < X_MIN)
        code |= LEFT;
    else if (x > X_MAX)
        code |= RIGHT;
    if (y < Y_MIN)
        code |= BOTTOM;
    else if (y > Y_MAX)
        code |= TOP;
    return code;
}

// Function to clip a line segment using midpoint algorithm
void midpointLineClipping(int x1, int y1, int x2, int y2) {
    int code1 = computeRegionCode(x1, y1);
    int code2 = computeRegionCode(x2, y2);
    int accept = 0;

    while (1) {
        if (!(code1 | code2)) { // Both endpoints are inside the window
            accept = 1;
            break;
        } else if (code1 & code2) { // Both endpoints are outside the window
            break;
        } else {
            int x, y;
            int codeOut = code1 ? code1 : code2;

            if (codeOut & TOP) { // Point is above the clip window
                x = x1 + (x2 - x1) * (Y_MAX - y1) / (y2 - y1);
                y = Y_MAX;
            } else if (codeOut & BOTTOM) { // Point is below the clip window
                x = x1 + (x2 - x1) * (Y_MIN - y1) / (y2 - y1);
                y = Y_MIN;
            } else if (codeOut & RIGHT) { // Point is to the right of the clip window
                y = y1 + (y2 - y1) * (X_MAX - x1) / (x2 - x1);
                x = X_MAX;
            } else if (codeOut & LEFT) { // Point is to the left of the clip window
                y = y1 + (y2 - y1) * (X_MIN - x1) / (x2 - x1);
                x = X_MIN;
            }

            if (codeOut == code1) {
                x1 = x;
                y1 = y;
                code1 = computeRegionCode(x1, y1);
            } else {
                x2 = x;
                y2 = y;
                code2 = computeRegionCode(x2, y2);
            }
        }
    }

    // If the line segment is accepted, draw it
    if (accept) {
        setcolor(WHITE);
        line(x1, y1, x2, y2);
    }
}

int main() {
    int x1, y1, x2, y2;
    int gd = DETECT, gm;
    initgraph(&gd, &gm, "C:\\TURBOC3\\BGI");

    // Draw clipping window
    rectangle(X_MIN, Y_MIN, X_MAX, Y_MAX);

    // Draw line segment
    printf("Enter coordinates of line (x1 y1 x2 y2): ");
    scanf("%d %d %d %d", &x1, &y1, &x2, &y2);
    setcolor(BLUE);
    line(x1, y1, x2, y2);

    // Clip the line segment
    midpointLineClipping(x1, y1, x2, y2);

    getch();
    cleardevice();

    // Draw clipping window again
    printf("Clipped Figure:");
    rectangle(X_MIN, Y_MIN, X_MAX, Y_MAX);
    midpointLineClipping(x1, y1, x2, y2);

    getch();
    closegraph();
    return 0;
}
//50 150 350 250

------------------------------------------------------------------------------------------------------------------------------------------

27. Write a Program to implement Sutherland-Hodgeman Polygon clipping algorithm.

#include <graphics.h>
#include <conio.h>
#include <stdio.h>

#define round(a) ((int)(a + 0.5))

int k;
float xmin, ymin, xmax, ymax, arr[20], m;

void clipleft(float x1, float y1, float x2, float y2) {
    if (x2 - x1)
        m = (y2 - y1) / (x2 - x1);
    else
        m = 100000;
    if (x1 >= xmin && x2 >= xmin) {
        arr[k] = x2;
        arr[k + 1] = y2;
        k += 2;
    }
    if (x1 < xmin && x2 >= xmin) {
        arr[k] = xmin;
        arr[k + 1] = y1 + m * (xmin - x1);
        arr[k + 2] = x2;
        arr[k + 3] = y2;
        k += 4;
    }
    if (x1 >= xmin && x2 < xmin) {
        arr[k] = xmin;
        arr[k + 1] = y1 + m * (xmin - x1);
        k += 2;
    }
}

void cliptop(float x1, float y1, float x2, float y2) {
    if (y2 - y1)
        m = (x2 - x1) / (y2 - y1);
    else
        m = 100000;
    if (y1 <= ymax && y2 <= ymax) {
        arr[k] = x2;
        arr[k + 1] = y2;
        k += 2;
    }
    if (y1 > ymax && y2 <= ymax) {
        arr[k] = x1 + m * (ymax - y1);
        arr[k + 1] = ymax;
        arr[k + 2] = x2;
        arr[k + 3] = y2;
        k += 4;
    }
    if (y1 <= ymax && y2 > ymax) {
        arr[k] = x1 + m * (ymax - y1);
        arr[k + 1] = ymax;
        k += 2;
    }
}

void clipright(float x1, float y1, float x2, float y2) {
    if (x2 - x1)
        m = (y2 - y1) / (x2 - x1);
    else
        m = 100000;
    if (x1 <= xmax && x2 <= xmax) {
        arr[k] = x2;
        arr[k + 1] = y2;
        k += 2;
    }
    if (x1 > xmax && x2 <= xmax) {
        arr[k] = xmax;
        arr[k + 1] = y1 + m * (xmax - x1);
        arr[k + 2] = x2;
        arr[k + 3] = y2;
        k += 4;
    }
    if (x1 < xmax && x2 > xmax) {
        arr[k] = xmax;
        arr[k + 1] = y1 + m * (xmax - x1);
        k += 2;
    }
}

void clipbottom(float x1, float y1, float x2, float y2) {
    if (y2 - y1)
        m = (x2 - x1) / (y2 - y1);
    else
        m = 100000;
    if (y1 >= ymin && y2 >= ymin) {
        arr[k] = x2;
        arr[k + 1] = y2;
        k += 2;
    }
    if (y1 < ymin && y2 >= ymin) {
        arr[k] = x1 + m * (ymin - y1);
        arr[k + 1] = ymin;
        arr[k + 2] = x2;
        arr[k + 3] = y2;
        k += 4;
    }
    if (y1 >= ymin && y2 < ymin) {
        arr[k] = x1 + m * (ymin - y1);
        arr[k + 1] = ymin;
        k += 2;
    }
}

void processAndDisplay() {
    int i;
    int gd = DETECT, gm, n, poly[20];
    float polyy[20];
    clrscr();
    printf("Coordinates of rectangular clip window:\nxmin, ymin:");
    scanf("%f %f", &xmin, &ymin);
    printf("xmax, ymax:");
    scanf("%f %f", &xmax, &ymax);
    printf("\n\nPolygon to be clipped:\nNumber of slides:");
    scanf("%d", &n);
    printf("Enter the coordinates:");
    for (i = 0; i < 2 * n; i++)
	scanf("%f", &polyy[i]);
    polyy[i] = polyy[0];
    polyy[i + 1] = polyy[1];
    for (i = 0; i < 2 * n + 2; i++)
	poly[i] = round(polyy[i]);
    initgraph(&gd, &gm, "c:\\turboc3\\bgi");
    setcolor(RED);
    rectangle(xmin, ymax, xmax, ymin);
    printf("\t\tUnclipped Polygon:");
    setcolor(WHITE);
    fillpoly(n, poly);
    getch();
    cleardevice();
    k = 0;
    for (i = 0; i < 2 * n; i += 2)
	clipleft(polyy[i], polyy[i + 1], polyy[i + 2], polyy[i + 3]);
    n = k / 2;
    for (i = 0; i < k; i++)
	polyy[i] = arr[i];
    polyy[i] = polyy[0];
    polyy[i + 1] = polyy[1];
    k = 0;
    for (i = 0; i < 2 * n; i += 2)
	cliptop(polyy[i], polyy[i + 1], polyy[i + 2], polyy[i + 3]);
    n = k / 2;
    for (i = 0; i < k; i++)
	polyy[i] = arr[i];
    polyy[i] = polyy[0];
    polyy[i + 1] = polyy[1];
    k = 0;
    for (i = 0; i < 2 * n; i += 2)
	clipright(polyy[i], polyy[i + 1], polyy[i + 2], polyy[i + 3]);
    n = k / 2;
    for (i = 0; i < k; i++)
	polyy[i] = arr[i];
    polyy[i] = polyy[0];
    polyy[i + 1] = polyy[1];
    k = 0;
    for (i = 0; i < 2 * n; i += 2)
	clipbottom(polyy[i], polyy[i + 1], polyy[i + 2], polyy[i + 3]);
    for (i = 0; i < k; i++)
	poly[i] = round(arr[i]);
    if (k)
	fillpoly(k / 2, poly);
    setcolor(RED);
    rectangle(xmin, ymax, xmax, ymin);
    printf("\tClipped Polygon:");
    getch();
    closegraph();
}

int main() {
    processAndDisplay();
    return 0;
}
//100 100
//400 400
//4
//50 50
//50 150
//150 150
//150 50

------------------------------------------------------------------------------------------------------------------------------------------

28. Write a Program to implement Generalized Polygon clipping algorithm.

#include <stdio.h>
#include <graphics.h>
#include<conio.h>

// Define clipping window coordinates
const int x_min = 100, y_min = 100, x_max = 400, y_max = 300;

// Function to draw the clipping window
void drawWindow() {
    rectangle(x_min, y_min, x_max, y_max);
}

// Function to check if a point is inside the clipping window
int inside(int x, int y, int edge) {
    if (edge == 1 && x >= x_min)
        return 1;
    if (edge == 2 && y <= y_max)
        return 1;
    if (edge == 3 && x <= x_max)
        return 1;
    if (edge == 4 && y >= y_min)
        return 1;
    return 0;
}

// Function to compute the intersection point of a polygon edge with a clipping window edge
void intersect(int x1, int y1, int x2, int y2, int edge, int* x, int* y) {
    switch (edge) {
        case 1: // Left edge
            *x = x_min;
            *y = y1 + (y2 - y1) * (x_min - x1) / (x2 - x1);
            break;
        case 2: // Top edge
            *x = x1 + (x2 - x1) * (y_max - y1) / (y2 - y1);
            *y = y_max;
            break;
        case 3: // Right edge
            *x = x_max;
            *y = y1 + (y2 - y1) * (x_max - x1) / (x2 - x1);
            break;
        case 4: // Bottom edge
            *x = x1 + (x2 - x1) * (y_min - y1) / (y2 - y1);
            *y = y_min;
            break;
    }
}

// Function to clip a polygon against a clipping window
void generalizedPolygonClipping(int poly[], int n) {
    int clipped[20]; // Clipped polygon vertices
    int k = 0; // Number of vertices in the clipped polygon
    int edge,i;

    for (edge = 1; edge <= 4; edge++) {
	int x_prev = poly[2 * n - 2];
	int y_prev = poly[2 * n - 1];

	for (i = 0; i < 2 * n; i += 2) {
	    int x = poly[i];
	    int y = poly[i + 1];

	    if (inside(x, y, edge)) {
		if (inside(x_prev, y_prev, edge)) {
		    // Both endpoints inside, add the current point to the output list
		    clipped[k++] = x;
		    clipped[k++] = y;
		} else {
		    // First point outside, second point inside, add intersection point to the output list
		    intersect(x_prev, y_prev, x, y, edge, &clipped[k], &clipped[k + 1]);
		    k += 2;
		    clipped[k++] = x;
		    clipped[k++] = y;
		}
	    } else if (inside(x_prev, y_prev, edge)) {
		// First point inside, second point outside, add intersection point to the output list
                intersect(x_prev, y_prev, x, y, edge, &clipped[k], &clipped[k + 1]);
                k += 2;
            }

            x_prev = x;
            y_prev = y;
        }

        // Copy the clipped polygon to the original array for the next iteration
	for (i = 0; i < k; i++) {
	    poly[i] = clipped[i];
	}
	n = k / 2;
	k = 0;
    }

    // Draw the clipped polygon
    setcolor(RED);
    drawpoly(n, clipped);
}

int main() {
     int poly[] = {150, 200, 300, 100, 400, 300, 250, 450,150,200};
    int n = sizeof(poly) / sizeof(poly[0]) / 2;
    int gd = DETECT, gm;
    initgraph(&gd, &gm, "c:\\turboc3\\bgi");

    // Draw the clipping window
    printf("Original Figure:");
    drawWindow();

    // Define the polygon vertices (clockwise order)


    // Draw the original polygon
    setcolor(YELLOW);
    drawpoly(n, poly);

    getch();
    cleardevice();
    setcolor(WHITE);
    drawWindow();

    // Clip and draw the polygon against the clipping window
    printf("Clipped Polygon:");
    generalizedPolygonClipping(poly, n);

    getch();
    closegraph();
    return 0;
}

------------------------------------------------------------------------------------------------------------------------------------------

29. Write a Program to draw a Koch curve upto ‘n’ iterations

#include <graphics.h>
#include <stdlib.h>
#include <math.h>

// Function to draw a Koch curve
void koch(int x1, int y1, int x2, int y2, int iterations) {
    if (iterations == 0) {
        // Draw a line if iterations are exhausted
        line(x1, y1, x2, y2);
    } else {
        // Calculate the intermediate points
        int x3 = x1 + (x2 - x1) / 3;
        int y3 = y1 + (y2 - y1) / 3;
        int x4 = x1 + 2 * (x2 - x1) / 3;
        int y4 = y1 + 2 * (y2 - y1) / 3;
        int x = x3 + (x4 - x3) / 2 - (y4 - y3) * sqrt(3) / 2;
        int y = y3 + (y4 - y3) / 2 + (x4 - x3) * sqrt(3) / 2;

        // Recursively draw the segments
        koch(x1, y1, x3, y3, iterations - 1);
        koch(x3, y3, x, y, iterations - 1);
        koch(x, y, x4, y4, iterations - 1);
        koch(x4, y4, x2, y2, iterations - 1);
    }
}

int main() {
    int x1 = 100, y1 = 200, x2 = 500, y2 = 200;
    int iterations;
    int gd = DETECT, gm;
    initgraph(&gd, &gm, "C:\\TURBOC3\\BGI");

    // Set initial points of the Koch curve
    

    // Input the number of iterations
    
    printf("Enter the number of iterations: ");
    scanf("%d", &iterations);

    // Draw the Koch curve
    koch(x1, y1, x2, y2, iterations);

    getch();
    closegraph();
    return 0;
}

//3 or 4

------------------------------------------------------------------------------------------------------------------------------------------

30. Write a Program to draw a Hilbert curve upto ‘n’ iterations.

#include <stdio.h>
#include <stdlib.h>
#include <graphics.h>
#include <math.h>


void move(int j, int h, int *x, int *y) {
    if (j == 1)
	*y -= h;
    else if (j == 2)
	*x += h;
    else if (j == 3)
	*y += h;
    else if (j == 4)
	*x -= h;
    lineto(*x, *y);
}

void hilbert(int r, int d, int l, int u, int i, int h, int *x, int *y) {
    if (i > 0) {
	i--;
	hilbert(d, r, u, l, i, h, x, y);
	move(r, h, x, y);
	delay(100);
	hilbert(r, d, l, u, i, h, x, y);
	move(d, h, x, y);
	delay(100);
	hilbert(r, d, l, u, i, h, x, y);
	move(l, h, x, y);
	delay(100);
	hilbert(u, l, d, r, i, h, x, y);
    }
}

int main() {
    int n, x0 = 50, y0 = 150, x, y, h = 10, r = 2, d = 3, l = 4, u = 1;
    int gm, gd = DETECT;
    initgraph(&gd, &gm, "C:\\Turboc3\\bgi");

    printf("Enter the value of n for Hilbert Curve: ");
    scanf("%d", &n);
    x = x0;
    y = y0;
    moveto(x, y);
    hilbert(r, d, l, u, n, h, &x, &y);
    delay(100);
    getch();

    closegraph();
    return 0;
}

//3 or 4

------------------------------------------------------------------------------------------------------------------------------------------

31. Write a Program to draw a Bezier curve upto ‘n’ iterations using midpoint method.
//its a cpp file
#include <stdio.h>
#include <graphics.h>
#include <stdlib.h>
#include <math.h> // Include math.h for round function
#include <dos.h>  // Include dos.h for delay function

// Pre-defined 5-sided polygon vertices
int pentagonX[] = {200, 250, 350, 400, 300};
int pentagonY[] = {350, 200, 200, 350, 400};
int numPentagonPoints = sizeof(pentagonX) / sizeof(pentagonX[0]);

double round(double x) {
    return floor(x + 0.5);
}

// Function to evaluate a point on the Bezier curve using de Casteljau's algorithm
void evaluateBezierPoint(int *x, int *y, int *controlPointsX, int *controlPointsY, int numPoints, float t) {
    int *tempX = (int *)malloc(numPoints * sizeof(int));
    int *tempY = (int *)malloc(numPoints * sizeof(int));

    // Initialize temporary arrays with control points
    for (int i = 0; i < numPoints; i++) {
        tempX[i] = controlPointsX[i];
        tempY[i] = controlPointsY[i];
    }

    // Apply de Casteljau's algorithm recursively
    for (int r = 1; r < numPoints; r++) {
        for (int i = 0; i < numPoints - r; i++) {
            tempX[i] = round((1 - t) * tempX[i] + t * tempX[i + 1]);
            tempY[i] = round((1 - t) * tempY[i] + t * tempY[i + 1]);
        }
    }

    // Assign the final evaluated point
    *x = tempX[0];
    *y = tempY[0];

    // Free temporary arrays
    free(tempX);
    free(tempY);
}

// Function to draw Bezier curve using midpoint method
void drawBezierCurve(int numPoints, int *controlPointsX, int *controlPointsY) {
    float t;
    int prevX, prevY;
    for (t = 0.0; t <= 1.0; t += 0.001) {
        int x_pixel, y_pixel;
        evaluateBezierPoint(&x_pixel, &y_pixel, controlPointsX, controlPointsY, numPoints, t);
        if (t > 0.0) {
            line(prevX, prevY, x_pixel, y_pixel);
        }
        prevX = x_pixel;
        prevY = y_pixel;
    }
}

// Function to draw pre-defined polygon
void drawPolygon(int *x, int *y, int numPoints) {
    for (int i = 0; i < numPoints - 1; i++) {
        line(x[i], y[i], x[i + 1], y[i + 1]);
    }
    line(x[numPoints - 1], y[numPoints - 1], x[0], y[0]); // Connect the last point to the first to close the polygon
}

int main() {
    int gd = DETECT, gm;
    int numPoints;

    printf("Enter the number of control points (n >= 2): ");
    scanf("%d", &numPoints);

    if (numPoints < 2) {
        printf("Invalid input. Number of control points must be at least 2.\n");
        return 1;
    }

    int *x = (int *)malloc(numPoints * sizeof(int));
    int *y = (int *)malloc(numPoints * sizeof(int));

    printf("Enter the coordinates of control points:\n");
    for (int i = 0; i < numPoints; i++) {
        printf("Control Point %d (x, y): ", i + 1);
        scanf("%d %d", &x[i], &y[i]);
    }

    initgraph(&gd, &gm, "C:\\TurboC3\\BGI");

    // Draw pre-defined polygon
    drawPolygon(pentagonX, pentagonY, numPentagonPoints);

    // Draw Bezier curve using midpoint method
    drawBezierCurve(numPoints, x, y);

    delay(5000);
    closegraph();

    free(x);
    free(y);
    return 0;
}
//3
//200 350
//350 250
//400 350

------------------------------------------------------------------------------------------------------------------------------------------

32. Write a Program to draw a coastline using Fractal line upto ‘n’ iterations.

#include <stdio.h>
#include <stdlib.h>
#include <graphics.h>
#include <conio.h>
#include <math.h>

// Function to draw fractal coastline
void drawCoastline(int x1, int y1, int x2, int y2, int n) {
    if (n == 0) {
        line(x1, y1, x2, y2);
    } else {
        int dx = x2 - x1;
        int dy = y2 - y1;

        // Calculate midpoints with some randomness
        int mx = (x1 + x2) / 2 + rand() % (2 * n) - n;
        int my = (y1 + y2) / 2 + rand() % (2 * n) - n;

        drawCoastline(x1, y1, mx, my, n - 1);
        drawCoastline(mx, my, x2, y2, n - 1);
    }
}

int main() {
     // Set initial endpoints of coastline
    int x1 = 100, y1 = 400;
    int x2 = 500, y2 = 400;
     int n;
    int gd = DETECT, gm;
    initgraph(&gd, &gm, "C:\\Turboc3\\BGI");

    // Set random seed
    srand(time(NULL));

   

    // Number of iterations
   
    printf("Enter the number of iterations: ");
    scanf("%d", &n);

    // Draw coastline recursively
    drawCoastline(x1, y1, x2, y2, n);

    getch();
    closegraph();
    return 0;
}
 //8

-----------------------------------------------------------------------------------------------------------------------------------------

33. Write a Program to draw a mountain using Fractal surface upto ‘n’ iterations.

#include <stdio.h>
#include <stdlib.h>
#include <graphics.h>
#include <conio.h>
#include <math.h>
#include <time.h>

// Function to draw fractal mountain
void drawMountain(int x1, int y1, int x2, int y2, int x3, int y3, int n) {
    if (n == 0) {
        line(x1, y1, x2, y2);
        line(x2, y2, x3, y3);
        line(x3, y3, x1, y1);
    } else {
        int mx1 = (x1 + x2) / 2 + rand() % (2 * n) - n;
        int my1 = (y1 + y2) / 2 + rand() % (2 * n) - n;
        int mx2 = (x2 + x3) / 2 + rand() % (2 * n) - n;
        int my2 = (y2 + y3) / 2 + rand() % (2 * n) - n;
        int mx3 = (x3 + x1) / 2 + rand() % (2 * n) - n;
        int my3 = (y3 + y1) / 2 + rand() % (2 * n) - n;

        drawMountain(x1, y1, mx1, my1, mx3, my3, n - 1);
        drawMountain(mx1, my1, x2, y2, mx2, my2, n - 1);
        drawMountain(mx3, my3, mx2, my2, x3, y3, n - 1);
    }
}

int main() {
    // Set initial vertices of the triangle
    int x1 = 100, y1 = 400;
    int x2 = 300, y2 = 200;
    int x3 = 500, y3 = 400;
     int n;
    int gd = DETECT, gm;
    initgraph(&gd, &gm, "C:\\Turboc3\\BGI");

    // Set random seed
    srand(time(NULL));

    

    // Number of iterations
   
    printf("Enter the number of iterations: ");
    scanf("%d", &n);

    // Draw mountain recursively
    setcolor(GREEN);
    drawMountain(x1, y1, x2, y2, x3, y3, n);

    getch();
    closegraph();
    return 0;
}
//10

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

ANIMATION

1. Pendulum

#include <graphics.h>
#include <math.h>
#include <conio.h>



// Bresenham's Line Drawing Algorithm
void bresenhamLine(int x1, int y1, int x2, int y2) {
    int dx = abs(x2 - x1), dy = abs(y2 - y1);
    int sx = x1 < x2 ? 1 : -1;
    int sy = y1 < y2 ? 1 : -1;
    int err = dx - dy, e2;
    
    while (1) {
        putpixel(x1, y1, WHITE);
        if (x1 == x2 && y1 == y2) break;
        e2 = 2 * err;
        if (e2 > -dy) { err -= dy; x1 += sx; }
        if (e2 < dx) { err += dx; y1 += sy; }
    }
}

// Bresenham's Circle Drawing Algorithm
void bresenhamCircle(int xc, int yc, int r) {
    int x = 0, y = r, d = 3 - 2 * r;
    while (y >= x) {
        putpixel(xc + x, yc + y, WHITE);
        putpixel(xc - x, yc + y, WHITE);
        putpixel(xc + x, yc - y, WHITE);
        putpixel(xc - x, yc - y, WHITE);
        putpixel(xc + y, yc + x, WHITE);
        putpixel(xc - y, yc + x, WHITE);
        putpixel(xc + y, yc - x, WHITE);
        putpixel(xc - y, yc - x, WHITE);
        x++;
        if (d > 0) {
            y--;
            d = d + 4 * (x - y) + 10;
        } else {
            d = d + 4 * x + 6;
        }
    }
}

// Pendulum Swing Animation
void pendulumSwing() {
    int x1 = 320, y1 = 50, length = 150;
    float angle = -M_PI / 4, angleIncrement = 0.05;
    int direction = 1; // 1 for forward, -1 for backward

    while (!kbhit()) {
        int x2 = x1 + length * sin(angle);
        int y2 = y1 + length * cos(angle);

        cleardevice();
        bresenhamLine(x1, y1, x2, y2);
        bresenhamCircle(x2, y2, 10);

        delay(50);

        // Change the direction when reaching the ends
        if (angle >= M_PI / 4) {
            direction = -1;
        } else if (angle <= -M_PI / 4) {
            direction = 1;
        }
        angle += direction * angleIncrement;
    }
}

int main() {
    int gd = DETECT, gm;
    initgraph(&gd, &gm, "C:\\Turboc3\\BGI");

    pendulumSwing();

    closegraph();
    return 0;
}

------------------------------------------------------------------------------------------------------------------------------------------

2. Circle inside circle

#include <graphics.h>
#include <math.h>
#include <stdio.h>
#include <conio.h>

// Function to draw a circle using Bresenham's algorithm
void drawCircle(int xc, int yc, int x, int y) {
    putpixel(xc + x, yc + y, WHITE);
    putpixel(xc - x, yc + y, WHITE);
    putpixel(xc + x, yc - y, WHITE);
    putpixel(xc - x, yc - y, WHITE);
    putpixel(xc + y, yc + x, WHITE);
    putpixel(xc - y, yc + x, WHITE);
    putpixel(xc + y, yc - x, WHITE);
    putpixel(xc - y, yc - x, WHITE);
}

// Bresenham's circle drawing algorithm
void bresenhamCircle(int xc, int yc, int r) {
    int x = 0, y = r;
    int d = 3 - 2 * r;
    drawCircle(xc, yc, x, y);
    while (y >= x) {
        x++;
        if (d > 0) {
            y--;
            d = d + 4 * (x - y) + 10;
        } else {
            d = d + 4 * x + 6;
        }
        drawCircle(xc, yc, x, y);
    }
}

// Function to rotate a point around a center
void rotatePoint(int xc, int yc, int x, int y, float angle, int *newX, int *newY) {
    *newX = xc + (x - xc) * cos(angle) - (y - yc) * sin(angle);
    *newY = yc + (x - xc) * sin(angle) + (y - yc) * cos(angle);
}

int main() {
    int gd = DETECT, gm;
    int xc = 320, yc = 240; // Center of the large circle
    int r = 100;            // Radius of the large circle
    int small_r = 20;       // Radius of the small circle
    float angle = 0.0;      // Initial angle
    int rotation_radius = r - small_r; // Radius of the rotation path
    initgraph(&gd, &gm, "C:\\Turboc3\\BGI");




    while (!kbhit()) {
  int small_x = xc + rotation_radius * cos(angle);
        int small_y = yc + rotation_radius * sin(angle);
        cleardevice();

        // Draw the large circle
        bresenhamCircle(xc, yc, r);

        // Calculate the position of the small circle
      

        // Draw the small circle at the calculated position
        bresenhamCircle(small_x, small_y, small_r);

        // Update the angle for the next frame
        angle += 0.05;

        delay(50);
    }

    closegraph();
    return 0;
}

------------------------------------------------------------------------------------------------------------------------------------------

3. Circle outside circle

#include <graphics.h>
#include <math.h>
#include <stdio.h>
#include <conio.h>

// Function to draw a circle using Bresenham's algorithm
void drawCircle(int xc, int yc, int x, int y) {
    putpixel(xc + x, yc + y, WHITE);
    putpixel(xc - x, yc + y, WHITE);
    putpixel(xc + x, yc - y, WHITE);
    putpixel(xc - x, yc - y, WHITE);
    putpixel(xc + y, yc + x, WHITE);
    putpixel(xc - y, yc + x, WHITE);
    putpixel(xc + y, yc - x, WHITE);
    putpixel(xc - y, yc - x, WHITE);
}

// Bresenham's circle drawing algorithm
void bresenhamCircle(int xc, int yc, int r) {
    int x = 0, y = r;
    int d = 3 - 2 * r;
    drawCircle(xc, yc, x, y);
    while (y >= x) {
        x++;
        if (d > 0) {
            y--;
            d = d + 4 * (x - y) + 10;
        } else {
            d = d + 4 * x + 6;
        }
        drawCircle(xc, yc, x, y);
    }
}

// Function to rotate a point around a center
void rotatePoint(int xc, int yc, int x, int y, float angle, int *newX, int *newY) {
    *newX = xc + (x - xc) * cos(angle) - (y - yc) * sin(angle);
    *newY = yc + (x - xc) * sin(angle) + (y - yc) * cos(angle);
}

int main() {
    int gd = DETECT, gm;
    int xc = 320, yc = 240; // Center of the large circle
    int r = 100;            // Radius of the large circle
    int small_r = 20;       // Radius of the small circle
    float angle = 0.0;      // Initial angle
    float bigCircleAngle = 0.0; // Angle for rotating the large circle
   int rotation_radius = r + small_r; // Radius of the rotation path
    initgraph(&gd, &gm, "C:\\Turboc3\\BGI");



 

    while (!kbhit()) {
 int rotatedX, rotatedY;
     int small_x = rotatedX + rotation_radius * cos(angle);
        int small_y = rotatedY + rotation_radius * sin(angle);
        cleardevice();

        // Rotate the center of the large circle around itself
       
        rotatePoint(xc, yc, xc, yc, bigCircleAngle, &rotatedX, &rotatedY);

        // Draw the large circle at the new position
        bresenhamCircle(rotatedX, rotatedY, r);

        // Calculate the position of the small circle
   

        // Draw the small circle at the calculated position
        bresenhamCircle(small_x, small_y, small_r);

        // Update the angles for the next frame
        angle += 0.05;
        bigCircleAngle += 0.01;

        delay(50);
    }

    closegraph();
    return 0;
}

------------------------------------------------------------------------------------------------------------------------------------------

4. Circle inside rectangle

#include <graphics.h>
#include <math.h>
#include <stdio.h>
#include <conio.h>

// Function to draw a circle using Bresenham's algorithm
void drawCircle(int xc, int yc, int x, int y) {
    putpixel(xc + x, yc + y, WHITE);
    putpixel(xc - x, yc + y, WHITE);
    putpixel(xc + x, yc - y, WHITE);
    putpixel(xc - x, yc - y, WHITE);
    putpixel(xc + y, yc + x, WHITE);
    putpixel(xc - y, yc + x, WHITE);
    putpixel(xc + y, yc - x, WHITE);
    putpixel(xc - y, yc - x, WHITE);
}

// Bresenham's circle drawing algorithm
void bresenhamCircle(int xc, int yc, int r) {
    int x = 0, y = r;
    int d = 3 - 2 * r;
    drawCircle(xc, yc, x, y);
    while (y >= x) {
        x++;
        if (d > 0) {
            y--;
            d = d + 4 * (x - y) + 10;
        } else {
            d = d + 4 * x + 6;
        }
        drawCircle(xc, yc, x, y);
    }
}

// Bresenham's line drawing algorithm
void bresenhamLine(int x1, int y1, int x2, int y2) {
    int dx = abs(x2 - x1), dy = abs(y2 - y1);
    int sx = (x1 < x2) ? 1 : -1;
    int sy = (y1 < y2) ? 1 : -1;
    int err = dx - dy,e2;
    
    while (1) {
        putpixel(x1, y1, WHITE);
        if (x1 == x2 && y1 == y2)
            break;
        e2 = 2 * err;
        if (e2 > -dy) {
            err -= dy;
            x1 += sx;
        }
        if (e2 < dx) {
            err += dx;
            y1 += sy;
        }
    }
}

int main() {
    int gd = DETECT, gm;

    int rectX1 = 100, rectY1 = 100; // Top-left corner of the rectangle
    int rectX2 = 500, rectY2 = 300; // Bottom-right corner of the rectangle
    int small_r = 10;               // Radius of the small circle

    float angle = 0.0;              // Initial angle
    int speed = 5;   

    initgraph(&gd, &gm, "C:\\Turboc3\\BGI");

               // Speed of the circle

    while (!kbhit()) {
 int small_x, small_y;
        cleardevice();

        // Draw the rectangle
        bresenhamLine(rectX1, rectY1, rectX2, rectY1); // Top side
        bresenhamLine(rectX2, rectY1, rectX2, rectY2); // Right side
        bresenhamLine(rectX2, rectY2, rectX1, rectY2); // Bottom side
        bresenhamLine(rectX1, rectY2, rectX1, rectY1); // Left side

        // Calculate the position of the small circle
       
        if (angle < 1.0) {
            small_x = rectX1 + (rectX2 - rectX1 - small_r * 2) * angle + small_r;
            small_y = rectY1 + small_r;
        } else if (angle < 2.0) {
            small_x = rectX2 - small_r;
            small_y = rectY1 + (rectY2 - rectY1 - small_r * 2) * (angle - 1.0) + small_r;
        } else if (angle < 3.0) {
            small_x = rectX2 - (rectX2 - rectX1 - small_r * 2) * (angle - 2.0) - small_r;
            small_y = rectY2 - small_r;
        } else {
            small_x = rectX1 + small_r;
            small_y = rectY2 - (rectY2 - rectY1 - small_r * 2) * (angle - 3.0) - small_r;
        }

        // Draw the small circle at the calculated position
        bresenhamCircle(small_x, small_y, small_r);

        // Update the angle for the next frame
        angle += 0.01 * speed;
        if (angle >= 4.0) {
            angle = 0.0;
        }

        delay(50);
    }

    closegraph();
    return 0;
}

------------------------------------------------------------------------------------------------------------------------------------------

6. Circle bouncing inside rectangle

#include <graphics.h>
#include <math.h>
#include <stdio.h>
#include <conio.h>

// Function to draw a circle using Bresenham's algorithm
void drawCircle(int xc, int yc, int x, int y) {
    putpixel(xc + x, yc + y, WHITE);
    putpixel(xc - x, yc + y, WHITE);
    putpixel(xc + x, yc - y, WHITE);
    putpixel(xc - x, yc - y, WHITE);
    putpixel(xc + y, yc + x, WHITE);
    putpixel(xc - y, yc + x, WHITE);
    putpixel(xc + y, yc - x, WHITE);
    putpixel(xc - y, yc - x, WHITE);
}

// Bresenham's circle drawing algorithm
void bresenhamCircle(int xc, int yc, int r) {
    int x = 0, y = r;
    int d = 3 - 2 * r;
    drawCircle(xc, yc, x, y);
    while (y >= x) {
        x++;
        if (d > 0) {
            y--;
            d = d + 4 * (x - y) + 10;
        } else {
            d = d + 4 * x + 6;
        }
        drawCircle(xc, yc, x, y);
    }
}

// Bresenham's line drawing algorithm
void bresenhamLine(int x1, int y1, int x2, int y2) {
    int dx = abs(x2 - x1), dy = abs(y2 - y1);
    int sx = (x1 < x2) ? 1 : -1;
    int sy = (y1 < y2) ? 1 : -1;
    int err = dx - dy,e2;
    
    while (1) {
        putpixel(x1, y1, WHITE);
        if (x1 == x2 && y1 == y2)
            break;
        e2 = 2 * err;
        if (e2 > -dy) {
            err -= dy;
            x1 += sx;
        }
        if (e2 < dx) {
            err += dx;
            y1 += sy;
        }
    }
}

int main() {
    int gd = DETECT, gm;
   int rectX1 = 100, rectY1 = 100; // Top-left corner of the rectangle
    int rectX2 = 500, rectY2 = 300; // Bottom-right corner of the rectangle
    int small_r = 10;               // Radius of the small circle

    int small_x = rectX1 + small_r; // Initial x position of the small circle
    int small_y = rectY1 + small_r; // Initial y position of the small circle

    int dx = 1; // x direction of movement
    int dy = 1; // y direction of movement
    initgraph(&gd, &gm, "C:\\Turboc3\\BGI");



    while (!kbhit()) {
	cleardevice();

	// Draw the rectangle
	bresenhamLine(rectX1, rectY1, rectX2, rectY1); // Top side
	bresenhamLine(rectX2, rectY1, rectX2, rectY2); // Right side
	bresenhamLine(rectX2, rectY2, rectX1, rectY2); // Bottom side
	bresenhamLine(rectX1, rectY2, rectX1, rectY1); // Left side

	// Draw the small circle at the calculated position
	bresenhamCircle(small_x, small_y, small_r);

	// Update the position of the small circle
	small_x += dx;
	small_y += dy;

	// Check for collision with the rectangle boundaries and reverse direction if needed
	if (small_x + small_r >= rectX2 || small_x - small_r <= rectX1) {
	    dx = -dx;
	}
	if (small_y + small_r >= rectY2 || small_y - small_r <= rectY1) {
	    dy = -dy;
	}

	delay(5);
    }

    closegraph();
    return 0;
}

------------------------------------------------------------------------------------------------------------------------------------------

7. Ball rolling down the hill

#include <graphics.h>
#include <math.h>
#include <stdio.h>
#include <conio.h>

void drawCircle(int xc, int yc, int r) {
    int x = 0, y = r;
    int d = 3 - 2 * r;
    while (y >= x) {
        putpixel(xc + x, yc + y, WHITE);
        putpixel(xc - x, yc + y, WHITE);
        putpixel(xc + x, yc - y, WHITE);
        putpixel(xc - x, yc - y, WHITE);
        putpixel(xc + y, yc + x, WHITE);
        putpixel(xc - y, yc + x, WHITE);
        putpixel(xc + y, yc - x, WHITE);
        putpixel(xc - y, yc - x, WHITE);
        if (d > 0) {
            y--;
            d = d + 4 * (x - y) + 10;
        } else {
            d = d + 4 * x + 6;
        }
        x++;
    }
}

// Bresenham's line drawing algorithm
void bresenhamLine(int x1, int y1, int x2, int y2) {
    int dx = abs(x2 - x1), dy = abs(y2 - y1);
    int sx = (x1 < x2) ? 1 : -1;
    int sy = (y1 < y2) ? 1 : -1;
    int err = dx - dy,e2;
    
    while (1) {
        putpixel(x1, y1, WHITE);
        if (x1 == x2 && y1 == y2)
            break;
        e2 = 2 * err;
        if (e2 > -dy) {
            err -= dy;
            x1 += sx;
        }
        if (e2 < dx) {
            err += dx;
            y1 += sy;
        }
    }
}

int main() {
    int gd = DETECT, gm;
    int x1 = 100, y1 = 100; // Top vertex of the right-angled triangle
    int x2 = 100, y2 = 400; // Bottom-left vertex of the triangle
    int x3 = 500, y3 = 400; // Bottom-right vertex of the triangle
    int r = 10;             // Radius of the ball

    // Calculate the slope of the hypotenuse
    float slope = (float)(y3 - y1) / (x3 - x1);

    // Calculate the angle of the hypotenuse
    float angle = atan(slope);

    // Initial position of the ball
    int ball_x = x1 - r * sin(angle);
    int ball_y = y1 + r * cos(angle);

    // Speed of the ball
    int speed = 4;
    initgraph(&gd, &gm, "C:\\Turboc3\\BGI");



    while (!kbhit()) {
        cleardevice();

        // Draw the right-angled triangle
        bresenhamLine(x1, y1, x2, y2); // Left side
        bresenhamLine(x2, y2, x3, y3); // Bottom side
        bresenhamLine(x1, y1, x3, y3); // Hypotenuse

        // Draw the ball at the current position
        drawCircle(ball_x, ball_y, r);

        // Update the position of the ball
        ball_x += speed;
        ball_y = y1 + slope * (ball_x - x1) - r * sin(angle);

        // Ensure the ball remains on the hypotenuse by adjusting for the radius
        ball_y -= r * cos(angle);

        // Check if the ball reaches the bottom of the hypotenuse
        if (ball_x >= x3 + r * sin(angle)) {
            ball_x = x1 - r * sin(angle); // Reset the ball position to the top
            ball_y = y1 + r * cos(angle);
        }

        delay(30);
    }

    closegraph();
    return 0;
}

------------------------------------------------------------------------------------------------------------------------------------------

8. Ball in a AC graph

#include <graphics.h>
#include <dos.h>
#include <stdio.h>
#include <conio.h>
#include <math.h>

#define PI 3.14159265
void brescir(int x, int y, int r, int color) {
    int i = 0, j = r, p = 3 - 2 * r;
    while (i <= j) {
        putpixel(x + i, y + j, color);
        putpixel(x - i, y - j, color);
        putpixel(x + j, y + i, color);
        putpixel(x - j, y - i, color);
        putpixel(x - i, y + j, color);
        putpixel(x + i, y - j, color);
        putpixel(x - j, y + i, color);
        putpixel(x + j, y - i, color);
        if (p < 0) {
            i++;
            p = p + 4 * i + 6;
        } else {
            i++;
            j--;
            p = p + 4 * (i - j) + 10;
        }
    }
}
int main()
{
    int centerX = 100; // Adjusted centerX for larger view
    int centerY = 200; // Adjusted centerY for larger view
    int amplitude = 100; // Increased amplitude for larger wave
    int wavelength = 200; // Increased wavelength for larger wave
    int i;
    float angle = 0;

    int gd = DETECT, gm, x, y;
    initgraph(&gd, &gm, "C:/TURBOC3/BGI");

    while (1)
    {
    cleardevice();

    // Draw the wave with two wavelengths
    for (i = 0; i < 4 * wavelength; i++) { // Increased range to display larger wave
        int waveY = centerY + (int)(amplitude * sin(i * 2 * PI / wavelength));
        putpixel(centerX + i, waveY, WHITE);
    }

    // Calculate position of moving brescir along wave pattern
    x = centerX + (int)(angle);
    y = centerY + (int)(amplitude * sin(angle * 2 * PI / wavelength)) - 8;

    // Draw the moving brescir
    brescir(x, y, 10,WHITE);

    // Delay to control the speed of moving brescir
    delay(5);

    // Update the angle for next position
        angle += 0.1;

        // Check if Enter key is pressed to exit
        if (kbhit()) {
            if (getch() == '\r')  // '\r' represents Enter key
                break;
        }
    }

    getch();
    closegraph();
    return 0;
}


------------------------------------------------------------------------------------------------------------------------------------------

10. Circle around triangle

#include <graphics.h>
#include <math.h>
#include <stdio.h>
#include <conio.h>

// Function to draw a triangle
void drawTriangle(int x1, int y1, int x2, int y2, int x3, int y3) {
    line(x1, y1, x2, y2);
    line(x2, y2, x3, y3);
    line(x3, y3, x1, y1);
}

// Function to draw a circle
void drawCircle(int xc, int yc, int radius) {
    circle(xc, yc, radius);
}

// Function to calculate distance between two points
float distance(int x1, int y1, int x2, int y2) {
    return sqrt(pow(x2 - x1, 2) + pow(y2 - y1, 2));
}

// Function to move the circle along the edge of the triangle
void moveAlongTriangle(int x1, int y1, int x2, int y2, int x3, int y3, float *cx, float *cy, float *target_x, float *target_y, float step) {
    // Check if the target is reached
    if (distance(*cx, *cy, *target_x, *target_y) < step) {
	// Set the next target point
	if (*target_x == x1 && *target_y == y1) {
	    *target_x = x2;
	    *target_y = y2;
	} else if (*target_x == x2 && *target_y == y2) {
	    *target_x = x3;
	    *target_y = y3;
	} else {
	    *target_x = x1;
	    *target_y = y1;
	}
    }

    // Move towards the target
    *cx += (*target_x - *cx) * step;
    *cy += (*target_y - *cy) * step;
}

int main() {
    int gd = DETECT, gm;
    int xc = 320, yc = 240; // Center of the large triangle
    int sideLength = 150;    // Length of each side of the triangle
    float angle = 0.0;       // Initial angle for orientation of the triangle
    float small_x, small_y;  // Initial position of the small circle
    float target_x, target_y; // Target position for the small circle
    float step = 0.5;       // Step size for movement
    int smallRadius = 10;    // Radius of the small circle
    float x1 = xc - sideLength / 2, y1 = yc + sideLength * sqrt(3) / 2;
    float x2 = xc + sideLength, y2 = yc + sideLength * sqrt(3) / 2;
    float x3 = xc + sideLength / 2, y3 = yc - sideLength * sqrt(3) / 2;
    initgraph(&gd, &gm, "C:\\Turboc3\\BGI");

    // Calculate the initial position of the small circle (resting on vertex)

    small_x = x1;
    small_y = y1;
    target_x = x2;
    target_y = y2;

    while (!kbhit()) {
	cleardevice();

	// Draw the large triangle
	drawTriangle(x1, y1, x2, y2, x3, y3);

	// Draw the small circle
	drawCircle(small_x, small_y, smallRadius);

	// Move the small circle along the edge of the triangle
	moveAlongTriangle(x1, y1, x2, y2, x3, y3, &small_x, &small_y, &target_x, &target_y, step);

	delay(100);
    }

    closegraph();
    return 0;
}

------------------------------------------------------------------------------------------------------------------------------------------

13. Clock

#include<stdio.h>
#include<graphics.h>
#include<dos.h>
void main()
{
	struct  time t;
	struct arccoordstype sec_arc, min_arc, hr_arc;
	int i;
	int gd = DETECT,gm;
	initgraph(&gd,&gm,"c://TurboC3//BGI");
	setcolor(RED);
	//Outer circle
	circle(320,240,100);
	circle(320,240,99);
	//Inner circle
	circle(320,240,80);
	circle(320,240,81);
	setcolor(WHITE);
	//mark four points
	line(320,160,320,165);//top
	line(320,320,320,325);//bottom
	line(400,240,395,240);//left
	line(240,240,245,240);//right

	while(!kbhit())
	{
		printf("Time is : %2d:%2d:%3d\r",t.ti_hour%12, t.ti_min, t.ti_sec);
		setcolor(0);
		line(320,240, sec_arc.xend, sec_arc.yend);
		line(320,240, min_arc.xend, min_arc.yend);
		line(320,240, hr_arc.xend, hr_arc.yend);
		//Store time into struct t
		gettime(&t);
		//hour
		setcolor(0);
		arc(320,240,270,90-(t.ti_hour*6*5),55);
		setcolor(YELLOW);
		getarccoords(&hr_arc);
		line(320,240, hr_arc.xend, hr_arc.yend);
		//minute
		setcolor(0);
		arc(320,240,270,90-t.ti_min*6,65);
		setcolor(CYAN);
		getarccoords(&min_arc);
		line(320,240, min_arc.xend, min_arc.yend);
		//center circle
		setcolor(WHITE);
		pieslice(320,240,0,360,5);
		//second
		setcolor(0);
		arc(320,240,270,90-t.ti_sec*6,75);
		setcolor(RED);
		getarccoords(&sec_arc);
		line(320,240, sec_arc.xend, sec_arc.yend);
		delay(250);
		}
	getch();
}

------------------------------------------------------------------------------------------------------------------------------------------

                   Coded By: Shriyog & Naresh 
               "Remember switching to your pendrive is always faster than giting ;)"

